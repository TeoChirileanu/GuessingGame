<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.BuildInterfaces</name>
    </assembly>
    <members>
        <member name="M:JetBrains.Build.Helpers.BuildHelpers.CreateWorkingDirectory(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Creates a working directory for realizing artifacts into files for the duration of the current build step.
            //TODO: add a possiblity of reuse between steps for speed.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.BuildHelpers.MakeDateTimeVersion(JetBrains.Util.Version2,System.Nullable{System.DateTime})">
            <summary>
            Version number based on date and time in its two last components.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.BuildHelpers.WithProgressMessagesAsync``1(JetBrains.DataFlow.OuterLifetime,System.String,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger,System.Func{System.Threading.Tasks.Task{``0}},System.Func{System.String})">
            <summary>
            Starts logging progress messages with <see cref="F:JetBrains.Util.LoggingLevel.INFO" /> level if the activity wrapped with this method takes long enough, and issues a final message with total time only if any intermediate messages were written.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Installation.ReferenceClosure">
            <summary>
            Helper class which provides facility to build reference closure of .NET assembly(ies).
            </summary>
            <remarks>
            Used in console tool installers to determine files neccessary for particular tool.
            </remarks>
            <example>
            <code>
            ReferenceClosure
              .Of(ConsoleRunner.AssemblyName, files)
              .IncludeAssembly("JetBrains.Common.ElevationAgent")
              .IncludeExtra(ourIncludeExtra)
              .Exclude(ourExclude)
              .Build();
            </code>
            </example>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.IncludeExtra(System.Collections.Generic.IEnumerable{JetBrains.Util.PathWildcard})">
            <summary>
            Includes in result set given extra files (by mask).
            </summary>
            <param name="wildcards"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.IncludeAssembly(System.String)">
            <summary>
            Includes in result set given assembly.
            </summary>
            <param name="assemblyName">assembly name (w/o extension)</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.Exclude(System.Collections.Generic.IEnumerable{JetBrains.Util.PathWildcard})">
            <summary>
            Excludes from result set given files (by mask).
            </summary>
            <param name="wildcards"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.Build">
            <summary>
            Builds reference closure against specified assemblies and includes given extra files.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.Of(System.String,System.Collections.Generic.IEnumerable{JetBrains.Util.Storage.SimpleFileItem})">
            <summary>
            Initiates <c>ReferenceClosure</c>.
            </summary>
            <param name="entryAssemblyName">entry-point assembly name (w/o extension)</param>
            <param name="files">all files which build step has produced</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Helpers.Metadata.IBuildTimeRealizedAssemblyItemUnification">
            <summary>
            Designates the <see cref="T:JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnification" /> instance which is used during build for realizing assemblies of the build engine and build entities.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog">
            <summary>
            When a subplatform nuget package is produced, a pre-calculated part catalog for its assemblies can be placed in the nuget package jet metadata.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog.Assemblies">
            <summary>
            Lists the assemblies for which catalog has been calculated.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog.AssembliesAndFiles">
            <summary>
            Lists the assemblies for which catalog has been calculated, as well as names of the files from which such assemblies should be loaded when needed.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog.PartCatalogTablesMemoryDump">
            <summary>
            A memory dump of the <see cref="T:JetBrains.Application.Table.CatalogTables" />.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildHelper">
            <summary>
            The default MSBuild setup for build tasks.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.GetDefaultMachineInstalled(JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Gets the default toolset for the current platform, as defined by <see cref="F:JetBrains.Util.ToolsetInfo.CurrentDevToolset" />.
            </summary>
            <param name="tasker">The task host is required to drive async operations.</param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.FromIdentity(JetBrains.Build.Helpers.Msbuild.ToolsetIdentity,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Creates a toolset for the given identity.
            </summary>
            <param name="identity">The identity (either a package id or a synthetic identity for the local machine, see class for details).</param>
            <param name="nugetter">Optionally, the nuget package manager is required to fetch the toolset's nuget package when the <paramref name="identity" /> specifies a package-based toolset.</param>
            <param name="tasker">The task host is required to drive async operations.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.FromMachineInstalled(JetBrains.Util.Version2,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.DotNetFrameworkArchitecture,JetBrains.Util.Storage.Packages.IJetNugetPackageManager)">
            <summary>
            Gets a toolset of the specific version installed on the current machine.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.GetEngineVersionAsync">
            <summary>
            Gets the toolset' MSBuild version.
            For packaged toolsets, this might mean retrieving and inspecting packages, so the async operation might not be immediate.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.GetPathToLoggerAssemblyAsync">
            <summary>
            When running msbuild, the client side might want to receive its logged events, such as errors, warnings, output, and progress messages.
            This gives the path to the <see cref="T:JetBrains.MSBuild.Logger.Api.IJetMsbuildLoggerApi" />-implementing assembly compatible with the current toolset.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.GetPathToMsbuildExeAsync">
            <summary>
            Gets the path to the MSBuild executable in the toolset.
            For packaged toolsets, this would mean retrieving ALL of the packages so that the toolset were ready for actually executing builds when the task completes, so the task might be slow when first called.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.OptionNeverUseTeamcityLogger">
            <summary>
            Prevents attempting to use the TC logger for MSBuild when running on TC. If not used, the MSBuild messages would be pumped thru as Logger messages and formatted for TC output.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.BuildTimeout">
            <summary>
            Gets or sets the timeout for running the child MSBuild process.
            The wait will be aborted when the timeout elapses, and child processes will be killed.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.EnvironmentVariables">
            <summary>
            Passes name-value pairs as environment variables of the child process.
            These are available as regular MSBuild property names in the script, first-level or nested, unless an MSBuild proprety with such a name has another value.
            Also available in any executables run from within MSBuild.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MsbuildToolset">
            <summary>
              <para>MSBuild toolset, which defines the MSBuild version and the compilers it would use.</para>
              <para>BY default, uses the version for the current platform, as given by <see cref="F:JetBrains.Util.ToolsetInfo.CurrentDevToolset" />.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Projects">
            <summary>
            One or more projects to build.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrder">
            <summary>
            Tells how the projects in the <see cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Projects" /> list should be ordered when being supplied to MSBuild.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Properties">
            <summary>
            Passes name-value pairs as MSBuild properties.
            These can't be overridden within the first-level MSBuild script, but calling a nested MSBuild task might override any values.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Verbosity">
            <summary>
              <para>Defines verbosity for MSBuild output.</para>
              <para>This property is favored over PS standard "-Verbose" so that it could be easier parameterized on TC and so that it were uniform between MSBuild loggers and out output. All output always goes to the standard output pipeline.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.AddTarget(JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownTargets)">
            <summary>
            A shortcut for setting certain well-known targets.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.BuildAsync">
            <summary>
            Starts the build session with an output into the default logger.
            The logger has an unique random suffix to differentiate output from this specific run from other sessions running in parallel.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.BuildAsync(JetBrains.DataFlow.OuterLifetime,JetBrains.Util.ILogger)">
            <summary>
            Starts the build session, allows to abort the run and to output build progress into a custom logger.
            It is recommended for the custom logger to have an unique random suffix on the category if it gets output to the global common logger, for telling the sessions running in parallel apart.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.SetProperties(JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties)">
            <summary>
            A shortcut for setting certain well-known properties for the MSBuild with their typed values.
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.EmitTmpBuildFileIfNeeded(JetBrains.DataFlow.Lifetime,JetBrains.Util.ILogger)">
            <summary>
              Problem: MSBuild.exe won't take multiple projects to build. But we still want to be able to do it (running them just in sequence is suboptimal and also fails to utilize the multi-node build).
              If this is the case, we'd emit a temporary build file which spawns the build of our projects via the MSBuild task.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MakeStartInfoCommandLineAsync(JetBrains.MSBuild.Logger.Api.IJetMsbuildLoggerApiSession,JetBrains.Util.FileSystemPath,JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.LoggerMode,JetBrains.Util.ILogger)">
            <summary>
              Prepares the cmdline for spawning MSBuild.exe (path to exe + args string).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.DotNetFrameworkArchitecture">
            <summary>
            Used to specify the targeted bitness of the .NET Framework for some methods of ToolLocationHelper
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.LoggerMode.ContinuousIntegrationLoggerCmdlineArg">
            <summary>
            Cmdline modification if <see cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.LoggerMode.IsLoggingToContinuousIntegration" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.LoggerMode.IsLoggingToContinuousIntegration">
            <summary>
            Whether we're not reporting build errors and warnings to the regular build <see cref="T:JetBrains.Util.ILogger" />, but rather pumping them directly into the Continuous Integration server, to let it track wrn/err/nesting/progress/whatever with its APIs.
            Our own MSBuild in-process log listener is only used for counting errors and warnings in such a case.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MsbuildLoggerVerbosity">
            <summary>
            Borrowed from MSBuild.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MsbuildSummaryException">
            <summary>
            The finaly summary after an MSBuild run, about the warnings and the errors count, is posted to the logger as this exception object.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MsbuildSummaryException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Nodes.Single">
            <summary>
            Runs on the single node.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Nodes.Multiple">
            <summary>
            Runs on multiple nodes, as many as there're CPUs on this machine.
            </summary>
            <remarks>
            <b>ATTENTION:</b> Don't use <i>/m</i> option for msbuild is case more than one separate msbuilds were run simultaneously!!!
            <i>/nodeReuse:false</i> option doesn't grant that process tree will be the same as msbuild connection tree!!!
            The windows job object can kill msbuilds which were used for another parallel build runs!!!
            </remarks>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Nodes.Overbooking2x">
            <summary>
            Runs on multiple nodes, twice as many as there're CPUs on this machine.
            </summary>
            <remarks>
            <b>ATTENTION:</b> Don't use <i>/m</i> option for msbuild is case more than one separate msbuilds were run simultaneously!!!
            <i>/nodeReuse:false</i> option doesn't grant that process tree will be the same as msbuild connection tree!!!
            The windows job object can kill msbuilds which were used for another parallel build runs!!!
            </remarks>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering">
            <summary>
            Tells how the projects in the <see cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Projects" /> list should be ordered when being supplied to MSBuild.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering.AsInList">
            <summary>
            No sorting applied, the projects are dumped into MSBuild in the same order as they're in <see cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Projects" />, and MSBuild deals with their build order on itself.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering.Lexicographical">
            <summary>
            The projects are sorted lexicographically, to impose some stable ordering. MSBuild still rules out how to make the build correct against all of the dependencies.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering.ByProjectReferencesFlat">
            <summary>
            The invoker attempts to predict the correct build order of the projects and supply a partially-toposorted list to MSBuild. MSBuild still rules out how to make the build correct against all of the dependencies, so this sorting is not needed/guaranteed to be correct, but there's a supposition that it might improve build perf.
            All projects are fed into MSBuild in one batch.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering.ByProjectReferencesLayered">
            <summary>
            The invoker attempts to predict the correct build order of the projects and supply a partially-toposorted list to MSBuild. MSBuild still rules out how to make the build correct against all of the dependencies, so this sorting is not needed/guaranteed to be correct, but there's a supposition that it might improve build perf.
            Projects are fed into MSBuild with smaller batches so that all projects in a batch were not referencing each other. Cons: on a build error, further batches are not executed, unlike the flat mode.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.IgnoreWarnIntDirInTempDetected">
            <summary>
              <para>A property which allows to suppress the VC warning “Warning MSB8029. The Intermediate directory or Output directory cannot reside under the Temporary directory as it could lead to issues with incremental build.”, as defined in “C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V120\Microsoft.CppBuild.targets” etc.</para>
              <para>Server build would use temp folders for int/out dirs to ensure clean rebuild, so this property might be worth using to avoid unwanted warnings.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.IntermediateOutputPath">
            <summary>
            OBJ directory.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.OutDir">
            <summary>
            Directory for all output files.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.TargetPath">
            <summary>
            Path of the main output file (e.g. DLL).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.VisualStudioVersion">
            <summary>
              <para>Sets the <c>VisualStudioVersion</c> MSBuild global property.</para>
              <para>Has no specific meaning, but without it somehow a C++ build might fail with messages like “<c>Error MSB8008. Specified platform toolset (v110_xp) is not installed or invalid. Please make sure that a supported PlatformToolset value is selected.</c>”.</para>
              <para>If it does, set to the current VS version.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.FallbackLoggerBodyPackage">
            <summary>
            Used if the logger assembly cannot be found alongside the current runtime files. Loads the default logger implementation supposedly compatible with the machine-installed MSBuild.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.LoggerInterfaceType">
            <summary>
            Type of the Logger API Entry-Point interface.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.LoggerClientAssemblyName">
            <summary>
            Assembly name of the assembly with the logger client implementation of the <see cref="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.LoggerInterfaceType" /> to be loaded into the client process.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.LogReceiveHandler">
            <summary>
            Tracks receiving log messages.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.LogReceiveHandler.myMapNodeIdToLogger">
            <summary>
            So that to track messages in the parallel build, makes a separate category for each logger node.
            Procected with the neutran threading lock.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MachineInstalledMsbuildToolset">
            <summary>
            Uses an MSBuild installed on the local machine for running the build.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MachineInstalledMsbuildToolset.IsInstalled(JetBrains.Util.Version2,JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.DotNetFrameworkArchitecture)">
            <summary>
            Quick-checks if the given toolset version is installed locally on this machine, and if you might create a locally-installed msbuild toolset object of the said version.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MsbuildCompositeProjectEmitter">
            <summary>
              Writes an MSBuild project file which invokes a set of other project files.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroupElements.None">
            <summary>
            Results in an inclusion of a file with Build Action = None.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.None">
            <summary>
            Results in an inclusion of a file with Build Action = None.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.JetNetStandart">
            <summary>
            Special property for avoid override some important parts in new csproj project.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.UseSharedCompilation">
            <summary>
            Option for Roslyn which defines whether it's allowed to compile everything within the single process rather than run each compilation separately.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values">
            <summary>
            Values for properties etc.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Latest">
            <summary>
            <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.LangVersion" /> for Roslyn value for the latest supported language version.
            <code>
            /// &lt;summary&gt;
            /// The latest version of the language supported.
            /// &lt;/summary&gt;
            Latest = int.MaxValue,
            </code>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.None">
            <seealso cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.queue">
            <seealso cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.ErrorReport" />
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.IInvokeMsbuild">
            <summary>
            Import this interface as a build helper for running MSBuild with recommended settings.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.IInvokeMsbuild.CreateSessionAsync(JetBrains.Build.Helpers.Msbuild.ToolsetIdentity)">
            <summary>
            Creates a new session for running MSBuild, with all parameters set up accordingly with the currently preferred values, like toolset, degree of parallelism, and so on.
            </summary>
            <param name="toolset"></param>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset">
            <summary>
            Allows to use a custom MSBuild version from a Nuget package rather than
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.AllToolsetsExpandRoot">
            <summary>
            All toolsets' directory hierarchies are under this folder.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.Generation">
            <summary>
            Change whenever algorithm changes.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.#ctor(JetBrains.Util.Storage.Packages.PackageIdentity,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.FileSystemPath)">
            <summary>
            Creates the runnable MSBuild toolset.
            </summary>
            <param name="identityPackageWithToolset">A package which defines the toolset: contains MSBuild itself, plus references all of the SDK packages which need to be retrieved for it.</param>
            <param name="nugetter">Knows how to retrieve packages.</param>
            <param name="tasker">Knows how to run async operations, such as when local-restoring toolset files.</param>
            <param name="dirForToolsetOverride">Optional. The directory into which the toolset would be installed, if given. Otherwise, a uniquely-named folder under <see cref="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.AllToolsetsExpandRoot" />.</param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.Ctor_ToolsetIdentity">
            <summary>
            Calculates the hash identity for the current toolset.
            Uses the original package names; patched msbuild package name is formed from this identity.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.ExpandConfigFileMacrosAsync(JetBrains.Util.Storage.SimpleFileItem,JetBrains.Util.FileSystemPath,System.Collections.Generic.Dictionary{System.String,JetBrains.Util.AsyncLazy{JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.RestoredPackage}},JetBrains.Util.ILogger)">
            <summary>
            Takes the MSBuild config file, applies our macros which should reference the requested package expand locations on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.FilterByRuntime(System.Collections.Generic.IList{JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry},JetBrains.Util.ILogger)">
            <summary>
            Filters entries in the MSBuild package by the current runtime, if applicable.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.ExpandedToolsetInfo.LoggerAssemblyPath">
            <summary>
            Path to the MSBuild Toolset Logger, see <see cref="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.LoggerClientAssemblyName" />, if found in this toolset.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.ExpandedToolsetInfo.MsbuildExePath">
            <summary>
            Path to the expanded MSBuild.exe (which is invoked to start the build).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.ExpandedToolsetInfo.ThisToolsetExpandRoot">
            <summary>
            Our toolset (specific to the set of packages and version) is expanded under this folder.
            Other toolset versions / sets of packages occupy other folders.
            Either autogenerated based on a hash of toolset props, or user-provided.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.MsbuildNugetPatched.ProspectedExpandDir">
            <summary>
            Checks that we've encoded the correct directory into the package.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.MentionedPackage.CollectFromMsbuildConfig(System.Xml.Linq.XDocument,JetBrains.Util.RelativePath,JetBrains.Util.ILogger)">
            <summary>
            Reads the config, finds what looks like references to other packages.
            </summary>
            <param name="xdConfig">The msbuild config file XML.</param>
            <param name="relPathToMsbuildDirFromPackagesFolder">Path from the Packages folder to the dir which has msbuild.exe and this config file, supposing that msbuild is also expanded as a package. Needed to detect which of the paths are paths to the sibling packages.</param>
            <param name="logger"></param>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.ToolsetIdentity">
            <summary>
              A typed wrapper for the package identity (or a fake identity for a local toolset) to be used as a toolset spec, for
              locating all such places in the solutuion.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetIdentity.LocalMachineToolsetSyntheticId">
            <summary>
              To specify a toolset installed locally on the machine, give a <see cref="T:JetBrains.Build.Helpers.Msbuild.ToolsetIdentity" /> with this ID for the
              package id, and the toolset version for the version.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetIdentity.DefaultLocalMachineInstalledToolset">
            <summary>
              Identifies the MSBuild installed on the local machine, of the version which is the current default (see
              <see cref="T:JetBrains.Util.ToolsetInfo" />).
              Use the same ID if you want to specify a machine toolset of some other version.
              NOTE: CPU architectures are not exposed at the moment, always uses the same as the running tool, add to ID or to the
              semver if needed.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.AssemblyItemInPackage">
            <summary>
            Denotes an assembly item which has been retrieved from a Nuget package.
            Defers loading the actual assembly file content bytes until they're requested.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetConfigFileLocator">
            <summary>
            Accumulates sources from which Nuget config files might be retrieved. Polymorphic.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetConfigFileLocator.GetConfigFile(JetBrains.Build.Helpers.Nuget.NugetConfigFileLocator)">
            <summary>
            Uses the polymorphic locator (which might be overridden in Shell etc) to retrieve the config files.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild">
            <remarks>
              <para><c>NugetApplicationPackageConvention</c> — Nuget package layouts, locations, constants, etc for application shell aware needs.</para>
              <para><see cref="T:JetBrains.Util.Storage.Packages.NugetHelpers" /> — very generic Nuget helpers in the <c>Util</c>, not aware of Build nor Application Shell packages layout.</para>
              <para><see cref="T:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild" /> — Nuget services for supporting the Build infrasturcture and build operations not aware of the Application Shell packages.</para>
              <para><c>NugetHelpersShell</c> — Nuget services for working with the Application Shell packages.</para>
              <para><c>NugetApplicationPackageTasks</c> — Application Shell packages logic.</para>
            </remarks>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.NugetBulkOperationWithProgressSemaphore">
            <summary>
            We do not want to run an unbounded number of bulk nuget operations in parallel, they would use up the same HTTP (for download) or disk (for mass reads). Also, progress messages would mix up.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.GetPackagesWithProgressAsync(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.GetPackageRequest},System.String,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger)">
            <summary>
            A helper to get a group of packages in one take. Adds progress reports for the whole group process.
            </summary>
            <param name="requests">The packages to be retrieved, as the request structures which allow to match the request with the result without additional lookups.</param>
            <param name="sTaskDisplayName">A display name for this bulk operation, to show progress in case it takes considerable time to complete. Usually a noun.</param>
            <param name="lifetime"></param>
            <param name="packman"></param>
            <param name="tasker"></param>
            <param name="loggerOuter">Your parent logger. The impl creates an own logger instance to track messages from this bulk operation.</param>
            <returns>Those package items which were retrieved (no NULLs).</returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.LoadNugetSettingsGen2FromFile(JetBrains.Util.Storage.SimpleFileItem)">
            <summary>
            Loads given Nuget settings in gen2 format.
            </summary>
            <remarks>TODO: not in Util because it does not reference the gen2 nuget yet</remarks>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.LocalRestorePackagesWithProgressAsync(JetBrains.DataFlow.Lifetime,JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession,System.Collections.Generic.IEnumerable{JetBrains.Util.Storage.Packages.NugetPackageFileItem},System.String,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.OnError)">
            <summary>Runs restore for the list of the given packages against the given session (which defines the target directory for restore and the unused packages behavior). See other overloads for options to create the session automatically.</summary>
            <param name="packages">The packages to restore with the session, one by one.</param>
            <param name="sTaskDisplayName">A display name for this bulk operation, to show progress in case it takes considerable time to complete. Usually a noun.</param>
            <param name="tasker">Async driver.</param>
            <param name="onerror">Error reporting.</param>
            <param name="lifetime"></param>
            <param name="session">In this overload, you already have the session.</param>
            <returns>The description of the restored package (nullity depends on <paramref name="onerror" />).</returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.LocalRestorePackagesWithProgressAsync(JetBrains.DataFlow.OuterLifetime,JetBrains.Util.Storage.Packages.NugetPackageFileItem,JetBrains.Util.FileSystemPath,JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.BacklogBehavior,System.String,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.OnError)">
            <summary>
            Creates the session with recommended parameters and runs restore in it for the given packages (when you have only one; use the other overload if there are many).
            </summary>
            <param name="lifetime">The limiting lifetime for the async activity.</param>
            <param name="packageIfSingle">The list of packages to be restored within this session, if there's only one package. Do use the other overload if you have many.</param>
            <param name="dirForRestore">The target directory for restore, corresponds to the <c>Packages</c> directory under the solution.</param>
            <param name="onUnusedPackages">What to do with unused packages in that <paramref name="dirForRestore" />. See <see cref="T:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.BacklogBehavior" /> for details.</param>
            <param name="sTaskDisplayName">A display name for this bulk operation, to show progress in case it takes considerable time to complete. Usually a noun.</param>
            <param name="tasker">Async driver.</param>
            <param name="onerror">Error reporting.</param>
            <returns>The description of the restored package (nullity depends on <paramref name="onerror" />).</returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.LocalRestorePackagesWithProgressAsync(JetBrains.DataFlow.OuterLifetime,System.Collections.Generic.IEnumerable{JetBrains.Util.Storage.Packages.NugetPackageFileItem},JetBrains.Util.FileSystemPath,JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.BacklogBehavior,System.String,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.OnError)">
            <summary>
            Creates the session with recommended parameters and runs restore in it for the given packages.
            </summary>
            <param name="lifetime">The limiting lifetime for the async activity.</param>
            <param name="packages">The list of packages to be restored within this session.</param>
            <param name="dirForRestore">The target directory for restore, corresponds to the <c>Packages</c> directory under the solution.</param>
            <param name="onUnusedPackages">What to do with unused packages in that <paramref name="dirForRestore" />. See <see cref="T:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.BacklogBehavior" /> for details.</param>
            <param name="sTaskDisplayName">A display name for this bulk operation, to show progress in case it takes considerable time to complete. Usually a noun.</param>
            <param name="tasker">Async driver.</param>
            <param name="onerror">Error reporting.</param>
            <returns>The description of the restored packages (depending on <paramref name="onerror" />, might be missing some of the original packages in case they failed).</returns>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.GetPackageRequest.Identity">
            <summary>
            MUST be specified. The package to retrieve.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.GetPackageRequest.Result">
            <summary>
            Requester's functor to process the result (as this is the most natural mapping of the result to the identity for the requester).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.PackageAssemblyItems.AssemblyItems">
            <summary>
            The assembly items of the package.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetHelpersBuild.PackageAssemblyItems.PartCatalog">
            <summary>
            Optional. The package might have a pre-calculated part catalog for its assemblies.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetConfigFile">
            <summary>
              <para>Configuration file for Nuget which tells where to download packages from.</para>
              <para>If not given explicitly, gets autodetected by <see cref="T:JetBrains.Build.Helpers.Nuget.NugetConfigFileLocator" /> from either local path or app-specific locations.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetConfigFileLocalPath">
            <summary>
            Input artifact for defining <see cref="T:JetBrains.Build.Helpers.Nuget.NugetConfigFile" /> with outer-world parameters for a build runner, as a path to the disk file.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild">
            <summary>
            In-build entities use these pre-configured Nuget package managers to retrieve or locally-install packages during build.
            This version is bound to build-specific Nuget servers.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild.myMemCache">
            <summary>
            Caches the nuget in-mem while it's still in use somewhere. Access must be protected by locking on this instance.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild.CleanupExpiredFoldersInCentralCacheAsync(JetBrains.DataFlow.OuterLifetime)">
            <summary>
            Checks if it's time to cleanup expired folders in CC, does so if yes.
            </summary>
            <param name="lifetimeLimit"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties">
            <summary>
            Emulates TC properties.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties.LoadHybridPropertiesFile(JetBrains.Util.FileSystemPath)">
            <summary>
            Loads a properties file in Java Properties Xml format which has all the kinds of properties in it (config &amp; system), told apart by the prefix.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties.LoadHybridPropertiesFile(System.IO.Stream)">
            <summary>
            Loads a properties file in Java Properties Xml format which has all the kinds of properties in it (config &amp; system), told apart by the prefix.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties.LoadHybridPropertiesXmlFile(JetBrains.Util.FileSystemPath)">
            <summary>
            Loads a properties file in Java Properties Xml format which has all the kinds of properties in it (config &amp; system), told apart by the prefix.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties.LoadHybridPropertiesXmlFile(System.IO.Stream)">
            <summary>
            Loads a properties file in Java Properties Xml format which has all the kinds of properties in it (config &amp; system), told apart by the prefix.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.Escape(System.String)">
            <summary>
            Performs TeamCity-format escaping of a string.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.EscapeEx(System.String)">
            <summary>
            Performs TeamCity-format escaping of a string.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.SendMessageCore(System.String,JetBrains.Util.dataStructures.FrugalLocalList{JetBrains.Util.Pair{System.String,System.String}},System.IO.TextWriter)">
            <summary>
            Writes the message.
            Writing MUST occur in one write operation to ensure thread-safety.
            </summary>
            <param name="sMessageName"></param>
            <param name="parameters"></param>
            <param name="writer"></param>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.MessageContext.NamelessValue(System.String)">
            <summary>
            Sends a nameless value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.MessageContext.Send">
            <summary>
            Writes the message.
            Writing MUST occur in one write operation to ensure thread-safety.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityNetfxTools.TryGetTeamCityMsbuildLoggerParam(System.Version,JetBrains.Build.Helpers.TeamCity.TeamCityProperties)">
            <summary>
              Gets the parameter value for MSBuild's "/logger:" parameter which connects it to the TeamCity logger, if currently running in a TeamCity build agent.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityNetfxTools.TryGetTeamCityNunitLauncherExe(JetBrains.Build.Helpers.TeamCity.TeamCityProperties)">
            <summary>
              Gets the parameter value for MSBuild's "/logger:" parameter which connects it to the TeamCity logger, if currently running in a TeamCity build agent.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.TeamCity.TeamCityProperties">
            <summary>
              While running within a TeamCity build, we have three sets of properties available:
              (1) Environment. These are available thru the process environment block.
              (2) System. There's a pointer to the properties file in one of the environment variables.
              (3) Configuration.There's a pointer to the properties file in one of the system properties (see the chain?).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.#ctor">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.IsRunningInTeamCity">
            <summary>
            The instance property which tells if the instance is running in TC.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.CreateFromRunningTeamCity">
            <summary>
            Creates from the currently-running TeamCity instance.
            Throws an exception if there is none. See <see cref="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.AssertIsRunningInTeamCity" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.GetIsRunningInTeamCity">
            <summary>
            The static version of <see cref="F:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.IsRunningInTeamCity" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.ReadJavaProperties(JetBrains.Util.FileSystemPath)">
            <summary>
            Reads the native version of the JAVA properties file.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.ReadJavaProperties(System.IO.Stream)">
            <summary>
            Reads the native version of the JAVA properties file.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.ReadJavaPropertiesXml(JetBrains.Util.FileSystemPath)">
            <summary>
            Reads the XML version of the JAVA properties file.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.ReadJavaPropertiesXml(System.IO.Stream)">
            <summary>
            Reads the XML version of the JAVA properties file.
            </summary>
        </member>
        <member name="T:JetBrains.Build.BuildArtifactAttribute">
            <summary>
            Marks a class which is a build artifact type.
            </summary>
            <remarks>
              <para>Artifact is what you request of the build as its result. There're also intermediate artifacts which are required to produce the final result.</para>
              <para>All of the information required for build steps must be conveyed in the form of artifacts (on which the build step explicitly depends), rather than files on disk, environment variables, or other means of implicit dependencies.</para>
              <para><see cref="T:JetBrains.Build.BuildStepAttribute">Build steps</see> and artifacts together would make the build chain.</para>
            </remarks>
        </member>
        <member name="T:JetBrains.Build.BuildErrorException">
            <summary>
            Formats a build message in a way which is compatible with MSBuild output, which makes it parseable by standard build output parsers (for detecting build errors from text etc).
            </summary>
        </member>
        <member name="M:JetBrains.Build.BuildErrorException.#ctor(System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Exception)">
            <param name="kind">Message kind, like "error", "warning", etc. The exception uses "error" by default.</param>
        </member>
        <member name="M:JetBrains.Build.BuildErrorException.FormatBuildMessage(System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Formats a build message in a way which is compatible with MSBuild output, which makes it parseable by standard build output parsers (for detecting build errors from text etc).
            </summary>
            <param name="kind">Message kind, like "error", "warning", etc.</param>
        </member>
        <member name="T:JetBrains.Build.BuildPartAttribute">
            <summary>
            Base for all build-related attributes which should be pulled into the part catalog.
            </summary>
        </member>
        <member name="T:JetBrains.Build.BuildStepAttribute">
            <summary>
              <para>Defines a build step by marking either a class or a method.</para>
              <para>A method is the simplest build step: its parameters are inputs it requires, and its return value is the artifacts it produces. To produce more than one artifact, use <see cref="T:System.Tuple" /> family types.</para>
            </summary>
            <remarks>
            While artifacts hold the build data, build steps define the actions which produce artifacts.
            There're no explicit dependencies between build steps. By inputing and outputing artifacts, the steps get dependent on each other via the information they deal with.
            </remarks>
        </member>
        <member name="T:JetBrains.Build.Cardinality">
            <summary>
            Whether the artifact is allowed to have more than one value.
            </summary>
            <remarks>
            Each build artifact is either having only one value, or holding a set of values.
            This property is defined when declaring the artifact, and all of the usages must match the choice.
            You cannot mismatch cardinality when importing an artifact into your build step (even though you might output a single value for supplying a plural artifact).
            </remarks>
        </member>
        <member name="T:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction">
            <summary>
            The basic implementation which operates on scattered DLLs, and can be used to locate the engine DLLs for a simple non-shelled build runner. Might use the part catalog as a hint.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction.BuildEngineAssemblyWellKnownSimpleName">
            <summary>
            Assume well-known assembly name (once again this is for manual bootstrapping, so will be updated if seen failing).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction.CollectBuiltInEngineDlls(JetBrains.Application.Components.Optional{JetBrains.Application.Catalogs.PartCatalogSet})">
            <summary>
            We're running the Build Runner Core on a set of scattered DLLs, all in one folder.
            This implementation loads the Build Engine DLL by its well-known name and traces all of the DLL refs from it.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction.GetEngineAssemblyToStartWith">
            <summary>
            Gets the engine assembly either from the part catalog by the well-known attribute, or by loading the disk assembly by well-known name in the ad-hoc scenario.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction.GetEngineAssemblyToStartWith(JetBrains.Application.Components.Optional{JetBrains.Application.Catalogs.PartCatalogSet})">
            <summary>
            Gets the engine assembly either from the part catalog by the well-known attribute, or by loading the disk assembly by well-known name in the ad-hoc scenario.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildEngineImplementationAttribute">
            <summary>
            Marks the class which creates the entry point to the build engine implementation. Helps with locating it in the catalog (and its assembly as well).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.BuildLogRecord.Metadata">
            <summary>
            Record metadata which allows to transfer machine-readable notifications alongside with regular text logging.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildOutputFileArtifact">
            <summary>
            Base class for build artifacts which are designated as build stage output files, and which should be available as individual files on disk after the build runs.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildOutputFileArtifact.TryReadFromStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Checks if the storage has been written with a serialized form of some <see cref="T:JetBrains.Build.Running.BuildOutputFileArtifact" />, and reads the file contents if so.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildOutputPackageFileArtifact">
            <summary>
            Base class for build artifacts which are designated as build stage output files, and which should be available as individual files on disk after the build runs.
            Specifically stores a package.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.RunCommand(JetBrains.Build.Running.BuildRunnerCommandString,JetBrains.Build.Running.BuildRunner.BeforeSessionStartHandler,JetBrains.Build.Running.BuildRunner.SessionStartedHandler)">
            <summary>
            Core impl for the external simple shell-less build runners, like cmdline and TeamCity.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.DefaultOnBeforeSessionStart(JetBrains.Build.Running.BuildRunnerRequest)">
            <summary>
            Tries to infer the build runner environment from request parameters.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunner.BeforeSessionStartHandler">
            <summary>
            Called before the session is started (and created).
            </summary>
            <param name="request">The build request to create the session off, partly filled with <see cref="T:JetBrains.Build.Running.BuildRunnerCommandString" />, fill with any additional stuff.</param>
            <returns>Optional. The engine environment, if available.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunner.SessionStartedHandler">
            <summary>
            Called after the session starts.
            </summary>
            <param name="lifetime">LT of the sessinsession, synced.</param>
            <param name="session">The session object, along with the session's log entries and results.</param>
            <returns>A task, in case the callee has to complete certain async tasks before shutting down the build completely. This would be waited before the runner returns.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunner.Stub">
            <summary>
            A stub for calling cross-domain.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.Stub.#ctor(System.String,System.IntPtr)">
            <summary>
            Runs the core version of the build, without spawning the full shell, with direct stdout (no TC formatting).
            </summary>
            <param name="sBuildRunnerCommandString">Build runner command string in the standard format.</param>
            <param name="pdwRetval">The return value of the run: a pointer to a DWORD where it should be written.</param>
            <returns>Result code, negative for a failure, S_OK if clean, S_FALSE if nearly ok but there were warnings.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.Stub.TmpLogIntoCommandLine(JetBrains.Util.Threading.SynchronizedLifetime,JetBrains.Util.LoggingLevel,JetBrains.Build.Running.BuildRunnerSession)">
            <summary>
            TODO: replace with promoting events to the caller side.
            </summary>
            <param name="lifetime"></param>
            <param name="loglevelMax"></param>
            <param name="session"></param>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunnerCommandString">
            <summary>
              <para><c>v1</c></para>
              <para>Defines the format of a JSON-formatted string to be passed as the build runner input in a lossless form (while cmdline args on Windows are not lossless for arbitrary text values because of the vage formatting/parsing rules).</para>
              <para>This format MUST NOT be changed as it is used by different-version build engine to talk to each other. Any newer reader MUST correctly read any previous format.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.vCurrent">
            <summary>
            The current version.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings">
            <summary>
            Artifact values in string-serialized form, keyed by artifact names.
            Extends <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings" /> by allowing to specify values for multiple instances of a plural artifact.
            </summary>
            <remarks>
            Implementations should populate artifacts with values from both <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings" /> and <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings" />; plural artifacts all the values from both sets, specifying values for a singular artifact in more than one set is an error.
            </remarks>
            <since>v2</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings">
            <summary>
            Artifact values in string-serialized form, keyed by artifact names.
            This is the original dictionary which only allows for one value per each name, thus prohibiting assignment of plural artifacts this way. See <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings" />.
            </summary>
            <remarks>
            Implementations should populate artifacts with values from both <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings" /> and <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings" />; plural artifacts all the values from both sets, specifying values for a singular artifact in more than one set is an error.
            </remarks>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactsValueSerializer">
            <summary>
            Raw artifact values in a <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> container in a structured storage.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildEngineFiles">
            <summary>
            File paths to build engine files.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildScriptBinaryFiles">
            <summary>
            File paths to build script binary files.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildScriptSourceFilesOrDirectories">
            <summary>
            Paths to directories with build script source files under them, or to individual build script source files.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.Objectives">
            <summary>
            Build objective artifact names.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.OutputsDir">
            <summary>
            Optional. If build outputs are file-based, they would be written to this directory as disk files.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.OutputsFile">
            <summary>
            Optional. Build outputs would be written to this file, as a structured storage.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.SerializedBuildRequestFile">
            <summary>
            Optional. Full path to the file which has the full build request in the structured storage serialized form. Note that this request is not format-invariant and MUST match exactly the version of the build engine you will be running it with. It must be produced and executed by the same version of the runner.
            </summary>
            <since>v3</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.v">
            <summary>
            Version marker, for side-by-side formats.
            </summary>
            <since>v1</since>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerCommandString.EnumAllArtifactStrings">
            <summary>
            Enumerates artifact string name-value pairs from both <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings" /> and <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings" />. Names might thus repeat in these pairs.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunnerEngineType">
            <summary>
            Values for <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.EngineChoice" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerEnvironment.IsBuildScriptCachingEnabled">
            <summary>
            Means the Engine can use machine cache for processing build script sources. This is meant to speed up local scenarios.
            Includes compilation of build script source core (in some scenarios) and building the parts catalog over the compiled build script binaries.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerEnvironment.NugetConfigFile">
            <summary>
            Nuget configuration.
            Build system mostly uses the list of Nuget sources out of this info, for retrieving the packages required for running the build.
            The packages taking part in the build itself are managed elsewhere, in build tasks, and might be using another config file.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunnerRequest">
            <summary>
            Default implementation for <see cref="T:JetBrains.Build.Running.IBuildRunnerRequest" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.BuildScriptBinaries">
            <summary>
            The already-compiled build script in the binary form.
            Supports assembly and package files as file items.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.BuildScriptSources">
            <summary>
            The source code of the build script which is compiled by the build engine.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.CustomEngineBinaries">
            <summary>
            Custom engine files for the <see cref="F:JetBrains.Build.Running.BuildRunnerEngineType.CustomCompiled" /> choice in <see cref="P:JetBrains.Build.Running.BuildRunnerRequest.EngineChoice" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.EngineChoice">
            <summary>
            If custom engine is selected, <see cref="P:JetBrains.Build.Running.BuildRunnerRequest.CustomEngineBinaries" /> must contain the custom engine assemblies and their satellite files.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.InputArtifacts">
            <summary>
            Input artifacts whose values are known before the build begins — from external parameters, or from the previous stage. In serialized form.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.InputArtifactStrings">
            <summary>
            Input artifacts whose values are known before the build begins — from external parameters, or from the previous stage. In string form, to be turned into a real artifact with <see cref="T:System.ComponentModel.TypeConverter" /> or <see cref="T:System.Windows.Markup.ValueSerializer" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.Objectives">
            <summary>
            The artifacts to be calculated by the build.
            Build steps will be run so that to trace value from known <see cref="P:JetBrains.Build.Running.BuildRunnerRequest.InputArtifacts" /> and to the <see cref="P:JetBrains.Build.Running.BuildRunnerRequest.Objectives" />.
            Output values in <see cref="T:JetBrains.Build.Running.BuildRunnerResult" /> would contain these objectives, as well as any other artifacts which support serialization.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.StageDisplayName">
            <summary>
            Display name for the stage which will be run from this request.
            If omitted, the stage would use the objectives for the name.
            If starting a nested build stage, the runner might also prepend the parent stage name and the index of the child build to the given name.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.FillNestedRequestDelegate">
            <summary>
            You implement this callback to fill the request with your data for the nested build. The request is pre-filled with input artifacts, in object and string form, as taken from the currently running build, so that you could run the nested build on the same inputs (or filter them down).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.IBuildRunnerRequestEx.GetOrCreateStageDisplayName(JetBrains.Build.Running.IBuildRunnerRequest)">
            <summary>
            Gets a non-empty stage name, <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.StageDisplayName" /> if defined, or makes from <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives" /> if available, or a stub.
            </summary>
            <param name="thіs"></param>
        </member>
        <member name="M:JetBrains.Build.Running.IBuildRunnerRequestEx.WithSourcesFromDisk(JetBrains.Build.Running.IBuildRunnerRequest,JetBrains.Util.FileSystemPath,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Adds build script sources from the given list.
            </summary>
            <param name="thіs">The request to be filled.</param>
            <param name="dirRelativeRoot">Base dir for relative paths.</param>
            <param name="dirsOrFilesWithSources">The list of source directories in absolute or relative form, relative are based on the <paramref name="dirRelativeRoot" /> which must be specificed in this case.</param>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerResult.WithAnotherTypeBinder(JetBrains.Build.Serialization.IBindTypeByName)">
            <summary>
            Uses a more specific type binder, e.g. resolves artifact types in the context of the outer build.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerResultEx.ExtractAnythingWhichLooksLikeAFile(JetBrains.Build.Running.BuildRunnerResult)">
            <summary>
            Extracts any embedded files from the build runner results.
            </summary>
            <remarks>
            Actually, looks for any serialized records which look like files, and rips them out.
            </remarks>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerResultEx.ExtractBuildOutputFiles(JetBrains.Build.Running.BuildRunnerResult)">
            <summary>
            Extracts any embedded files from the build runner results.
            </summary>
            <remarks>
            Actually, looks for any serialized records which look like files, and rips them out.
            </remarks>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerSession.AsyncBuildResult">
            <summary>
            Gets the build result when it's ready.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildTaskHost">
            <summary>
            A default implementation for <see cref="T:JetBrains.Build.Running.IBuildTaskHost" /> which just wraps an existing <see cref="T:JetBrains.Application.Threading.Tasks.ITaskHost" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildTaskHost.FromTaskHost(JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Wraps the common interface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.BuildTaskHost.JetBrains#Application#Threading#Tasks#ITaskHost#QueueAt(JetBrains.DataFlow.Lifetime,System.Action,System.DateTimeOffset)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Running.BuildTaskHost.JetBrains#Application#Threading#Tasks#ITaskHost#QueueRecurring(JetBrains.DataFlow.Lifetime,System.Action,System.DateTimeOffset,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepInputInfo">
            <summary>
            Describes a build step input parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepIoInfo">
            <summary>
            Base type for a descriptor for build step's input and output items.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Data.BuildStepIoInfo.Cardinality">
            <summary>
            Whether this item has one or multple values.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepIoInfo.Flags">
            <summary>
            Parameter kinds.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepIoInfo.ItemType">
            <summary>
            For a singular item, same as <see cref="F:JetBrains.Build.Running.Data.BuildStepIoInfo.RawType" />, unless wrapped in a task or an optional. This would be the most unwrapped item type.
            For a plural item, the <see cref="F:JetBrains.Build.Running.Data.BuildStepIoInfo.RawType" /> might be the generic specialization of the container type, and this is the actual type of the plural item (container type parameter). Dependencies linking goes over this type.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepIoInfo.RawType">
            <summary>
            The raw type of the parameter — type of the method parameter, or method return value.
            If the method returns a tuple, it gets split before declaring individual output parameters for each member, so this field will be one of the tuple item types.
            For plurals, it is the container type. For wrappings (for tasks and optionals), it's the fully wrapped type.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepOutputInfo">
            <summary>
            Describes a build step output parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepParameterFlags">
            <summary>
            Modifier flags on build step params.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepParameterFlags.IsOptional">
            <summary>
            The parameter is optional.
            It is OK to import NULL or an empty collection if the artifact value is not defined, or a helper is not available.
            Currently, valid on input parameters only.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepParameterFlags.IsAsync">
            <summary>
            The parameter is a <see cref="T:System.Threading.Tasks.Task`1" /> async parameter.
            Initially implemented for output parameters to support <c>async</c> build steps. Possibly, might make sense to allow async input parameters for higher parallellism.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepRunnableClass">
            <summary>
            Build steps implemented as classes.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepRunnableMethod">
            <summary>
            Build steps implemented as methods.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Data.BuildStepRunnableMethod.RunAsync_SplitCompoundOutputs(System.Object)">
            <remarks>
            NOTE: must match the logic in <see cref="M:JetBrains.Build.Running.Data.BuildStepRunnableMethod.Ctor_ParseOutputTypes(JetBrains.Application.Catalogs.PartCatalogTypeMember,JetBrains.Build.Running.Data.BuildStepOutputInfo[]@,JetBrains.Build.Running.Data.BuildStepRunnableMethod.AssignOutputDelegate[]@,JetBrains.Build.Running.Data.BuildStepParameterFlags@,System.Boolean@)" />.
            </remarks>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepRunnableMethod.AssignInputDelegate">
            <summary>
            Before reflection-invoking the method, fills its parameters list with the step input values.
            </summary>
            <param name="stepinputs">The input values for the step.</param>
            <param name="index">Current input index.</param>
            <param name="reflectionparams">The parameter array which will be used for the call.</param>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepRunnableMethod.AssignOutputDelegate">
            <summary>
            After reflection-invoking the method, maps its outputs into the step outputs list.
            </summary>
            <param name="returns">The return values of the method, after splitting any possible tuples.</param>
            <param name="reflectionparams">The parameter array used for the call, might hold the out parameters.</param>
            <param name="index">Current output index.</param>
            <param name="stepoutputs">Assign step output here.</param>
        </member>
        <member name="T:JetBrains.Build.Running.IBuildRunnerRequest">
            <summary>
            This is the Build Runner Request object. Describes the inputs, objectives, and engine choice for the run.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinaries">
            <summary>
            The already-compiled build script in the binary form.
            Supports assembly and package files as file items.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptSources">
            <summary>
            The source code of the build script which is compiled by the build engine.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.CustomEngineBinaries">
            <summary>
            Custom engine files for the <see cref="F:JetBrains.Build.Running.BuildRunnerEngineType.CustomCompiled" /> choice in <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.EngineChoice" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.EngineChoice">
            <summary>
            If custom engine is selected, <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.CustomEngineBinaries" /> must contain the custom engine assemblies and their satellite files.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.InputArtifacts">
            <summary>
            Input artifacts whose values are known before the build begins — from external parameters, or from the previous stage. In serialized form.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.InputArtifactStrings">
            <summary>
            Input artifacts whose values are known before the build begins — from external parameters, or from the previous stage. In string form, to be turned into a real artifact with <see cref="T:System.ComponentModel.TypeConverter" /> or <see cref="T:System.Windows.Markup.ValueSerializer" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives">
            <summary>
            The artifacts to be calculated by the build.
            Build steps will be run so that to trace value from known <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.InputArtifacts" /> and to the <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives" />.
            Output values in <see cref="T:JetBrains.Build.Running.BuildRunnerResult" /> would contain these objectives, as well as any other artifacts which support serialization.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.StageDisplayName">
            <summary>
            Display name for the stage which will be run from this request.
            If omitted, the stage would use the objectives for the name.
            If starting a nested build stage, the runner might also prepend the parent stage name and the index of the child build to the given name.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.IBuildTaskHost">
            <inheritdoc cref="T:JetBrains.Application.Threading.Tasks.ITaskHost" />
            <remarks>A Build Helper designated task host interface.</remarks>
        </member>
        <member name="T:JetBrains.Build.Running.IBuiltInBuildEngineExtraction">
            <summary>
            An interface for separating Shell logic (which knows the files possibly belonging to the built-in build engine) and the build engine runner which needs the files but does not reference the Shell and all of than infrastructure.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.IIsolatedBuildRunners">
            <summary>
            Entry point interface to the build runner engine (top-level).
            When running inside the build, import the <see cref="T:JetBrains.Build.Running.INestedBuildRunner" /> build helper into your build step or helper to initiate a nested build.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.IIsolatedBuildRunners.BeginRunBuildScript(JetBrains.Util.Threading.SynchronizedLifetime,JetBrains.Build.Running.BuildRunnerRequest,JetBrains.Build.Running.BuildRunnerEnvironment)">
            <summary>
            Initiates a new build, async.
            </summary>
            <param name="lifetime">Build-limiting lifetime.</param>
            <param name="request">Build request (defines what to build and initial artifacts).</param>
            <param name="environment">Build environment with additional engine-specific env params, like where to pull Nuget packages for providing build script sources with.</param>
            <returns>Async build result.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.INestedBuildRunner.RunNestedBuildAsync(JetBrains.Util.Threading.SynchronizedLifetime,JetBrains.Build.Running.IBuildRunnerRequest)">
            <summary>
            Runs a nested build, asynchronously. You should await the result in your build step.
            </summary>
            <param name="lifetime">The lifetime for entities returned as a result of the build (as well as for all the build objects). Use local lifetimes if running many builds, to release build results.</param>
            <param name="request">Build request.</param>
            <returns>Build result.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.INestedBuildRunner.RunNestedBuildOnParentInputsAsync(JetBrains.Util.Threading.SynchronizedLifetime,JetBrains.Build.Running.FillNestedRequestDelegate)">
            <summary>
            Runs a nested build, asynchronously. You should await the result in your build step.
            </summary>
            <param name="lifetime">The lifetime for entities returned as a result of the build (as well as for all the build objects). Use local lifetimes if running many builds, to release build results.</param>
            <param name="λFillRequest">You implement this callback to fill the request with your data for the nested build. The request is pre-filled with input artifacts, in object and string form, as taken from the currently running build, so that you could run the nested build on the same inputs (or filter them down).</param>
            <returns>Build result.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.INestedBuildRunner.RunNestedBuildSync(JetBrains.DataFlow.Lifetime,JetBrains.Build.Running.IBuildRunnerRequest)">
            <summary>
            Runs a nested build, synchronously, which means that your build step does not proceed until the nested build completes.
            </summary>
            <param name="lifetime">The lifetime for entities returned as a result of the build (as well as for all the build objects). Use local lifetimes if running many builds, to release build results.</param>
            <param name="request">Build request.</param>
            <returns>Build result.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.InputArtifactStringName">
            <summary>
            When specifying input artifact values as strings, gives the name of the artifact to assign the string value to.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.InputArtifactStringName.FullOrLocalTypeName">
            <summary>
            Name of the artifact class type, as either a full or a local name (for nested classes, it's just the local name of the nested class, no outers' names added).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.InputArtifactStringName.IsIgnoringNonexistent">
            <summary>
            It's OK of the targeted artifact does not exist. Just skip assigning the value and issue a warning instead of an error.
            Should potentially be used when new artifacts are introduced to the build in some branch, but other branches still don't know about them — this allows the build configuration which is shared by all branches to define the values for the new artifacts without ruining older builds.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.InputArtifactStringName.Parse(System.String)">
            <summary>
            Applies the default convention where a name of the build artifact class which is OK to be missing is followed by a question sign.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutionPlanner.PlanCore(System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildEntity},System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildArtifactClass},JetBrains.Build.Running.Storage.BuildStorageCore)">
            <summary>
            Core planner, creates the step-by-step graph for dependencies.
            </summary>
            <param name="planneds">The build entities which have been hit while tracing undefined outputs back to available inputs (with unreachable optional parts dropped). We have to add specific Create/Delete/Execute steps for them, and impose ordering.</param>
            <param name="artifactsToKeep">These should be available as outputs after the plan is executed, so they should not be deleted.</param>
            <param name="storage">Build entities storage.</param>
            <returns>The plan, with detailed steps and a topo ordering on them.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutionPlanner.FindAndDropArtifactErrors(JetBrains.Build.Running.Storage.BuildStorageCore,System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildEntity},System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildArtifactClass})">
            <summary>
            Assert that any of the unresolved artifacts can actually be resolved with some steps.
            </summary>
            <param name="storage"></param>
            <param name="planneds"></param>
            <param name="unresolveds"></param>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutionPlanner.FindBestPath(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,JetBrains.Build.Running.Storage.IBuildEntity)">
            <summary>
            Prefers singular and very much prefers non-optional edges in the path.
            </summary>
            <param name="storage"></param>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutionPlanner.TakeDependenciesOfOutputs(JetBrains.Build.Running.Storage.BuildStorageCore,System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildArtifactClass},System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildEntity})">
            <summary>
            For each output, add what it depends on, transitively.
            That would be the largest possible work set, might only get filtered down if there're uncomposable optional subgraphs.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.Logger">
            <summary>
            The logger for regular writes.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.myLowLevelWriter">
            <summary>
            Optional lowlevel writer ONLY for passing metadata. All significant messages should go via <see cref="F:JetBrains.Build.Running.Logic.BuildExecutor.Logger" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Build.Running.Storage.BuildStorage,JetBrains.Build.Running.Storage.BuildExecutionPlan,JetBrains.Build.Running.BuildLogRecord.Writer,JetBrains.Build.Running.IBuildTaskHost,JetBrains.Util.ILogger)">
            <summary>
            </summary>
            <param name="lifetime"></param>
            <param name="storage">Build entity declarations and states, like artifact values and helper instances.</param>
            <param name="plan">The execution plan, a sequence of steps, helper creation/destruction, and artifact value decommissions.</param>
            <param name="writerLowLevel">Optional. The low-level writer to send up metadata on special activities, like passing the nested steps state.</param>
            <param name="tasker">Threading provider.</param>
            <param name="logger">The main logger for submitting progress messages and errors.</param>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.ExecutingItem">
            <summary>
              <para>The currently executing item, if doing one right now. Might get <c>Null</c>s during a run.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.IsRunning">
            <summary>
              <para>High when running.</para>
              <para>You can tell if it's “not yet run” or “have already run” by the value of <see cref="F:JetBrains.Build.Running.Logic.BuildExecutor.PlanPosition" />.</para>
              <para>This property changes free-threadedly, but under an exclusive lock together with other properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.PlanPosition">
            <summary>
              <para>The current position in the plan.</para>
              <para>It's <c>0</c> before execution.</para>
              <para>When executing an item, it's equal to the index of the currently executing item, in case of single-threaded execution. In multithreaded case, it's the number of items ever started to execute, and does not directly correspond to the Plan indices.</para>
              <para>After the run, it's the index after the end of the plan (equal to the Count).</para>
              <para>This property changes free-threadedly, but under an exclusive lock together with other properties.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.GetPlannedItemExecutionPriority(JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItem)">
            <summary>
            For the priority queue on planned items. Queue only holds items which do not have interdependencies, so this lines them up for optimal execution.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.ResolveStepInputs(JetBrains.Build.Running.Storage.BuildStorage,JetBrains.Build.Running.Storage.IBuildStepRunnable,JetBrains.Build.Running.Storage.EntityValueRetrievalContext,JetBrains.Util.ILogger)">
            <summary>
            Retrieve artifact values from the storage to fill step inputs.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.RunAsync_ReportExecutingItem(JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItem)">
            <summary>
            Advertise the item executed; as with tasks we now have parallel execution, only flash each item at the end of its execution
            </summary>
            <param name="planneditem"></param>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.RunStepAsync(JetBrains.Build.Running.Storage.IBuildStepRunnable,System.Object[],JetBrains.Util.ILogger)">
            <summary>
            Just invokes the step run on step-native data.
            The step MIGHT return unwaited tasks in some of its outputs. The only case when the step MUST wait for the tasks and unwrap the value is when the task covers more than one output, e.g. is a task of a tuple. As the step has to return split outputs, it has to await the task to split them.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.SubmitStepOutputsAsync(JetBrains.Build.Running.Storage.BuildStorage,JetBrains.Build.Running.Storage.IBuildStepRunnable,System.Object[],JetBrains.Util.ILogger)">
            <summary>
            After a step is executed, assigns its calculated outputs to the artifacts.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.BuildExecutor.Messages">
            <summary>
            Controls formatting of machine readable log messages.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.BuildExecutor.Parallelism">
            <summary>
            Whether planned items might be executed in parallel.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.Parallelism.Sequential">
            <summary>
            The next planned item only starts to execute after the previous completes its task chain. Even if the prev item sits on an await, the next item is not unblocked for execution. This does not prevent individual items from running activities in parallel, even by means of tasks.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.Parallelism.Maximum">
            <summary>
            The items are started as soon as all of their inputs are ready. Any number of items.
            The parallelism is then limited by the task scheduler capacity for active threads (by CPU count usually), which does not exactly mean the number of planned items, because if planned items are yielding on an await, a larger number might be in process of execution on the limited pool.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.CreateArtifact(JetBrains.DataFlow.Lifetime,JetBrains.Application.Catalogs.PartCatalogType,System.Nullable{JetBrains.Application.Catalogs.PartCatalogAttribute},JetBrains.Util.OnError)">
            <summary>
            A helper method to create a build artifact from the specific type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.CreateArtifact``1(JetBrains.DataFlow.Lifetime)">
            <summary>
            A helper method to create a build artifact from the specific type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.CreateArtifactFromValue``1(JetBrains.DataFlow.Lifetime,``0)">
            <summary>
            A helper method to create a build artifact from the specific artifact value (singular artifacts only).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.ExtractFromCatalog(JetBrains.DataFlow.Lifetime,JetBrains.Application.Catalogs.PartCatalog)">
            <summary>
            Creates artifact and build steps by reading the catalog.
            </summary>
            <param name="lifetime">Lifetime for the entities to be created.</param>
            <param name="catalog"></param>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.GetHiddenImplementations(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            For a type, calculates the set of types hidden by it — base types and <see cref="T:JetBrains.Application.Components.IHideImplementation`1" /> cases.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.TryGetWrapping(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            Gets the wrapping kind by checking the type, which should be in the form of the open generic definition type (e.g. <c>Full.Type.Name`1</c>).
            Checks the outermost wrapping only.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.TryUnwrap(JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Application.Catalogs.PartCatalogType@)">
            <summary>
            Gets the wrapping kind by checking the type, which should be in the form of the open generic definition type (e.g. <c>Full.Type.Name`1</c>).
            Checks the outermost wrapping only.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.WrapWithModifiers(System.Object,JetBrains.Build.Running.Data.BuildStepParameterFlags,JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Util.OnError)">
            <summary>
            For a wrapped item (with an <see cref="T:JetBrains.Application.Components.Optional`1" /> or a <see cref="T:System.Threading.Tasks.Task`1" /> or else of the supported values), wraps up the value to get the required outside type.
            </summary>
            <param name="theValue">The raw item value.</param>
            <param name="flags">Flags on the item, shows which wrappings are legal and expected.</param>
            <param name="pctypeTarget">The type which should be achieved after all of the wrappings are applied. Flags are not enough because the nesting order might vary.</param>
            <param name="onerror"></param>
            <returns>The wrapped object whose type equals to the runtime binding of the <paramref cref="!:pctypeTarget" />.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.StepInputOutputFromParameterType``1(JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Build.Running.Data.BuildStepParameterFlags@,System.Boolean)">
            <summary>
            </summary>
            <typeparam name="TBuildStepIoInfo"></typeparam>
            <param name="typeOriginalRaw">The original raw parameter with which we start the resolve.</param>
            <param name="typeCurrent">The current (possibly partially unwrapped) type which we are processing. This will eventually become the Item Type.</param>
            <param name="flags">The flags collected so far.</param>
            <param name="isTuplesAllowed">True for method return values, allows to unwrap multiple params from tuples.</param>
            <returns>A single type for in-params our out-params, and single or multiple for a return value (multiple if it's got a tuple).</returns>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.PluralContainers">
            <summary>
            Implementation support: for read (from out params / retvals), expecting all containers to implement <see cref="T:System.Collections.IEnumerable" />; for write (creating an object to be passed to an in param), expecting <see cref="T:System.Collections.Generic.List`1" /> to implement all of the supported container interfaces, but for the <see cref="T:System.Array" />, which is handled separately.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.Tuples">
            <summary>
            Support for tuples which allow passing more than one output type in method's return value.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.Tuples.ExtractTypesFromTuple(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            In case a method build step returns multiple artifact types, those might be packed into a tuple. This method returns the list of types to work with.
            </summary>
            <param name="typeMaybeTuple"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.Tuples.ExtractTypesFromTuple_SystemTuple(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            Either type type parameters, or an empty list if not recognized as a tuple.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.IBuildExecutorDrive">
            <summary>
            An interface for driving a proxy build executor object across the thread or apartment boundary.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BindArtifactTypeByName.#ctor(JetBrains.Build.Running.Storage.BuildStorage,JetBrains.Application.Catalogs.PartCatalog)">
            <summary>
            Sets up type binding which can bind the type by its fullname into another assembly in case it can't be found in its original assembly.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries">
            <summary>
            Stores binary files for use as a custom build engine, or a the pre-compiled build script.
            </summary>
            <remarks>Serves as a typed wrapper for telling apart storages with such data from any other ones.</remarks>
        </member>
        <member name="F:JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries.Files">
            <summary>
            The binary files for use as a custom build engine, or a the pre-compiled build script.
            Possible file types:
            • A managed assembly.
            • A satellite file.
            • A Nuget package, which is to be extracted to get any of these files yet again.
            • A Structured Storage with a serialized object of type <see cref="T:JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries" /> inside, which is to be extracted to get any of these files yet again.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries.IsInStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Gets whether this storage contains this object in a serialized form.
            // TODO: use serialization infrastructure info for this instead
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Serialization.BuildSerialization.StreamName_ArtifactEntityPointer">
            <summary>
            Current artifact type info, keeps just the build entity pointer in text form.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Serialization.BuildSerialization.StreamName_ArtifactProperties">
            <summary>
            Prev-gen artifact type info, in the property class.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildSerialization.ReadArtifact_EntityPointer(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,JetBrains.Util.OnError)">
            <summary>
            Helper for reading the entity pointer to the artifact, which gives the artifact type to create the instance.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Serialization.Build.DataHelpers.ArtifactProperties">
            <summary>
            <see cref="T:JetBrains.Build.Running.Serialization.BuildSerialization" /> serialization helper.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Serialization.BuildResultsRoot">
            <summary>
            Wraps a <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> with previous build results for typed access to a structured storage on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildResultsRoot.#ctor(JetBrains.Build.Serialization.SerializedValuesResolver)">
            <summary>
            Creates over an existing resolver.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildResultsRoot.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Creates over a storage with data. As usual, storage must be open while you're accessing this object.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildResultsRoot.IsInStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Gets whether this storage contains this object in a serialized form.
            // TODO: use serialization infrastructure info for this instead
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildResultsRoot.OpenStorageWithArtifacts(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Opens the child storage under the stored copy of <see cref="T:JetBrains.Build.Running.Serialization.BuildResultsRoot" /> which can be treated as <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> backend.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildEntityLifetime">
            <summary>
            Handles importing a lifetime into a build entity.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildEntityLogger">
            <summary>
            Handles importing a logger into a build entity so that the logger were configured with the entity's namespace and type name.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildEntityPointer">
            <summary>
            A serializable identification of a build entity.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildEntityPointer.myKindIndex">
            <summary>
            An index of the build entity kind in the <see cref="F:JetBrains.Build.Running.Storage.BuildEntityKinds.AllKinds" /> array.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildEntityPointer.AssemblyShortName">
            <summary>
              <para>Short name of the assembly which declares the entity.</para>
              <para>Might be empty for some entities because it does not form the strong identity anymore.</para>
              <para>Note: assembly excluded from identity because the same build entity might be compiled either as a part of the build script (into the source build entities assembly) or into the product package (into a product assembly). The entity equality must be retained, even though assembly names do differ.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.BuildEntityPointer.EntityKind">
            <summary>
            Gets the build entity kind of this entity.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.BuildEntityPointer.LocalName">
            <summary>
            Calculates the local name of the type, or type and member.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildEntityPointer.MemberName">
            <summary>
              <para>For type-based entities, an empty string.</para>
              <para>For member-based entities, the member name.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildEntityPointer.TypeFullName">
            <summary>
              <para>Full name of the type which declares the entity.</para>
              <para>Should be defined for all entities.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.Dependencies">
            <summary>
            Dependencies between the items in <see cref="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItems" />, as pairs of indices in the <see cref="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItems" /> list: the from-index and the to-index along the dependency flow, meaning that the to-item depends on the from-item. As the planned items are sorted in a ready-for-execution order, the second index in any pair is always larger than the first one.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.Objectives">
            <summary>
            The objectives of this plan.
            We're running this execution to obtain the values of these artifacts.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItems">
            <summary>
            The items planned for execution/creation/deletion.
            Sorted in a safe to execute order.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildExecutorRunResolveContext">
            <summary>
            A context for the whole build run.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildStepResolveContext">
            <summary>
            Works for the single build step only.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStepResolveContext.myLifetimeOutsideBody">
            <summary>
            A lifetime which is broader than that passed to the user in the build step body — to make sure all of the stuff created under it outlives any user code.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStepResolveContext.myLifetimeBuildStepBody">
            <summary>
            The lifeitme passed in constructor governs our object. For passing to user, make a nested lifetime.
            Basically equivalent to user's creating a <see cref="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})" /> lifetime, but more handy.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStepResolveContext.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Build.Running.Storage.IBuildStepRunnable,JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext)">
            <summary>
            </summary>
            <param name="lifetime">Lifetime for the context. Created only for the time of the single build step operation.</param>
            <param name="buildstep">The owning step.</param>
            <param name="contextRun">An outer context, for this build executor run.</param>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildStorage">
            <summary>
            An interface to the runtime storage of build steps and artifacts, as well as their relations (which steps are involved with the given artifact, etc).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorage.ResolveExact(JetBrains.Build.Running.Data.BuildStepIoInfo)">
            <summary>
            Resolves the input/output item into a type-based entity by its item type, also validating the cardinality.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorage.ResolveExact(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            Resolves a type-based entity by its originating type.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildStorageCore">
            <summary>
            Backend for <see cref="T:JetBrains.Build.Running.Storage.BuildStorage" /> which calculates and maintains all of the relations.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.BuildHelperHides">
            <summary>
            An outgoing reference means that its origin hides its destination (e.g. inherits).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheEntityByBaseType">
            <summary>
            All type-based build entities, by their exact type (as reported by entitry) and all of its assignable-to types, which includes base classes and interfaces. Runtime access: free, R/O.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheEntityByLocalName">
            <summary>
            All build entities cached by their local name. Runtime access: free, R/O.
            Note that there's no uniqueness guarantee for the local name really, so there might be more than one result.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheEntityByType">
            <summary>
            All type-based build entities, by their exact type (as reported by entitry). Runtime access: free, R/O.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheInputsResolution">
            <summary>
            Caches resolved inputs when filling the storage. Runtime access: free, R/O.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheOutputsResolution">
            <summary>
            Caches resolved outputs when filling the storage. Runtime access: free, R/O.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.Dependencies">
            <summary>
            Immediate dependencies between all the build entities.
            Edges go from outputs to inputs. If A depends on B, then it's from A and to B. This might be if step A takes input B, or step B returns output A.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.EntityInstances">
            <summary>
            Stores entity instances. Runtime access: free, R/W, beware concurrent modifications (by the build plan, should not be races on access to instances of the same entity).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.PointerToEntity">
            <summary>
            Looks up entities by entity pointers. Runtime access: free, R/O.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageCore.AddEntities(System.Collections.Generic.IList{JetBrains.Build.Running.Storage.IBuildEntity})">
            <summary>
            Adds a pack of (possibly mutually-dependent) entities to the build storage.
            All of the references must resolve either into this group or into the previously-registered entities.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageCore.AddEntities_EnsureCustomObjects(System.Collections.Generic.IList{JetBrains.Build.Running.Storage.IBuildEntity})">
            <summary>
            Makes sure that if the entity being added references the custom object entities, those are actually added to the storage too.
            Emits their entities on demand and adds to the list.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildStorageCore.EntityDependencyFlags">
            <summary>
            Flags on the entity dependency edges in the <see cref="F:JetBrains.Build.Running.Storage.BuildStorageCore.Dependencies" /> graph.
            Note that flags are not necessarily mutually exclusive because there might be multiple dependencies between two entities, and flags are merged among them.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageCore.InitDataFlow_AssertCachedByType(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{JetBrains.Build.Running.Storage.IBuildEntity},System.Collections.Generic.IDictionary{JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Build.Running.Storage.IBuildEntityOnType})">
            <summary>
            Type-based access to entities which are type-based.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageCore.IsGoodInputForBuildHelper(JetBrains.Build.Running.Storage.IBuildEntityOnType,JetBrains.Util.OnError)">
            <summary>
            Checks whether what we have resolved is legal to be assigned to a build helper's input.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageInstances.GetRunningInstance(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,JetBrains.Util.OnError)">
            <summary>
            Gets an already-created instance.
            This method is kept separated from <see cref="M:JetBrains.Build.Running.Storage.BuildStorageInstances.CreateEntityInstance(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,JetBrains.Util.OnError)" /> because an instance is created as a part of the execution plan at a certain iteration, and then must be available when the other iterations need its value.
            </summary>
            <returns>NotNull if throwing.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageInstances.SetEntityInstance(JetBrains.DataFlow.Lifetime,JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,System.Object,JetBrains.Util.OnError)">
            <summary>
            A pairing method for <see cref="M:JetBrains.Build.Running.Storage.BuildStorageInstances.GetRunningInstance(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,JetBrains.Util.OnError)" /> in case you already have an entity instance.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveAssignable(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Data.BuildStepInputInfo[][],JetBrains.Util.OnError)">
            <summary>
            Resolves an overload list to possible assignable type-based entities.
            </summary>
            <param name="storage"></param>
            <param name="overloads"></param>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveAssignable(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Data.BuildStepInputInfo,JetBrains.Util.OnError)">
            <summary>
            Resolves the input item into a type-based entity assignable to the parameter type, also validating the cardinality.
            NotNull, but reports an error if nothing were found.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveAssignable(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Util.OnError)">
            <summary>
            Resolves type-based entities which are assignable to the requested type.
            NotNull, but reports an error if nothing were found.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveExact(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Data.BuildStepIoInfo,JetBrains.Util.OnError)">
            <summary>
            Resolves the input/output item into a type-based entity by its item type, also validating the cardinality.
            </summary>
            <returns>NotNull in case of a throwing onerror.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveExact(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Util.OnError)">
            <summary>
            Resolves a type-based entity by its originating type.
            </summary>
            <returns>NotNull in case of a throwing onerror.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.IsResolveAllowed(JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Build.Running.Storage.IBuildEntityOnType,JetBrains.Util.OnError)">
            <summary>
            Checks if it's valid for an entity to be resolved from the specific type.
            E.g. build artifacts cannot be resolved by an arbitrary base type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.OverloadResolutionInfo.ToException">
            <summary>
            Builds an exception with an outline with all the information we collected, mostly in the exception data.
            By traversing the data tree, all of the details will be rendered.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageValues.UnwrapValue(System.Object,JetBrains.Build.Running.Data.BuildStepParameterFlags,JetBrains.Util.OnError)">
            <summary>
            Unwraps a runtime value possibly wrapped with <see cref="T:JetBrains.Application.Components.Optional`1" /> or <see cref="T:System.Threading.Tasks.Task`1" />. This is for reading the method output values. Sync version.
            </summary>
            <param name="value"></param>
            <param name="flags"></param>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageValues.UnwrapValueAsync(System.Object,JetBrains.Build.Running.Data.BuildStepParameterFlags,JetBrains.Util.OnError)">
            <summary>
            Unwraps a runtime value possibly wrapped with <see cref="T:JetBrains.Application.Components.Optional`1" /> or <see cref="T:System.Threading.Tasks.Task`1" />. This is for reading the method output values. Async version: chains waiting for the task result if async.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2">
            <summary>
            Adds a capacity of associating attributes to the graph edges.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.myMapEdgeData">
            <summary>
            Data on the edge.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.AddDependency(`0,`0,`1)">
            <summary>
            Sets edge data replacing the previous one, if there were any. Registers the dependency if the edge does not exist yet.
            </summary>
            <param name="from">From-node of the edge.</param>
            <param name="to">To-node of the edge.</param>
            <param name="edgedata">The new data to associate with the edge.</param>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.AddOrUpdateDependency(`0,`0,`1,System.Func{`1,`1,`1})">
            <summary>
            Sets edge data replacing the previous one, if there were any. Registers the dependency if the edge does not exist yet.
            </summary>
            <param name="from">From-node of the edge.</param>
            <param name="to">To-node of the edge.</param>
            <param name="edgedata">The new data to associate with the edge.</param>
            <param name="FCombineOldAndNew">Optional function to handle assigning data to an edge which already has data on it. Has a chance to combine datas based on whatever rules the graph owner thinks applicable.</param>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.TryGetEdge(`0,`0)">
            <summary>
            Gets the data associated with an edge.
            If there is no such edge in the graph, returns NULL.
            If the edge exists, but has no data associated with it, also returns NULL.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.TryGetEdgeData(`0,`0)">
            <summary>
            Gets the data associated with an edge.
            If there is no such edge in the graph, returns NULL.
            If the edge exists, but has no data associated with it, also returns NULL.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.EdgeEnd.OtherEnd">
            <summary>
            Some end of the edge, depending of whether we're considering incoming our outgoing edges.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.EntityValueRetrievalContext.#ctor(System.Func{JetBrains.DataFlow.Lifetime},JetBrains.Build.Running.Storage.IBuildEntity)">
            <summary>
            </summary>
            <param name="FImportLifetime">The lifetime, as it should be imported into the entity. It's a func mostly not because it's a lazy instance, but to outline that it's not a lifetime for this object.</param>
            <param name="entityImportingFor">The entity for which the values are imported in this context.</param>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildArtifactClass">
            <summary>
            Represents a build artifact and its calculated value, if any.
            Mark a class with <see cref="T:JetBrains.Build.BuildArtifactAttribute" /> to let use it as an artifact.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildArtifactClass.ArtifactValues">
            <summary>
              <para>Empty, if the artifact has not been calculated yet by the build.</para>
              <para>A single value, for a fully-defined <see cref="F:JetBrains.Build.Cardinality.Singular" /> artifact.</para>
              <para>One or more values, for a (partially or fully) defined <see cref="F:JetBrains.Build.Cardinality.Plural" /> artifact.</para>
              <para>New values might be added, but never removed.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildArtifactClass.Cardinality">
            <summary>
              <para>Whether the artifact value is singular or plural.</para>
              <para>If your data is a list of values, there's a choice: either define a singular artifact which holds the complete list inside, or a plural artifact class whch holds just one item, and there'll be a set of them during the build. The determination is whether different build steps might contribute to the list: a singular artifact can only be produced once by a single build step, and values for a plural artifact will be collected from all the producing steps.</para>
              <para>A singular artifact is imported just with the type of the artifact class. A plural artifact is imported as a <see cref="T:System.Collections.Generic.IEnumerable`1" />, <see cref="T:System.Collections.Generic.ICollection`1" /> or <see cref="T:System.Collections.Generic.IList`1" /> of the artifact class type.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildCustomObject">
            <summary>
            An entity for importing dynamically-created objects into other build entities, such as they're specific to those entities, such as lifetime, logger, etc.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntity">
            <summary>
            Common base for build-related entities which could have dependencies on each other etc.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityEx.EntityKindAndNameString">
            <summary>
            A delay-rendered string value.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityEx.EntityPointerKindAndNameString">
            <summary>
            A delay-rendered string value.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext">
            <summary>
            Gets or creates instances for build entities in a specific context.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityOnMember">
            <summary>
            Common base for a build entity which is produced out of a type member, and can be uniquely identified by that type member.
            An example is a method-based build step.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildEntityOnMember.Member">
            <summary>
            The type member on which this build entity is based on.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityOnType">
            <summary>
            Common base for a build entity which is produced out of a type, and can be uniquely identified by that type.
            Most entities are, but for maybe method-based build steps.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildEntityOnType.Type">
            <summary>
            The type on which this build entity is based on.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildHelper">
            <summary>
              <para>A build helper class, which could be imported into a build step as an input parameter.</para>
              <para>If not marked with the <see cref="F:JetBrains.Build.BuildHelperFlags.IsSingleton" /> flag, which is the preferrable default, is a throw-away class which can be created on-demand (maybe in multiple instances) and discarded at any time. These don't have to be serializable because a new instance can be created at any moment.</para>
              <para>If <see cref="F:JetBrains.Build.BuildHelperFlags.IsSingleton" />, the one and only instance might exist, and it should be serializable to support suspended builds.</para>
              <para>Free-threaded access possible.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildHelper.InputsChoice">
            <summary>
            Input parameters from various constructor overloads.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.IBuildHelper.CreateInstance(System.Collections.Generic.IList{JetBrains.Build.Running.Data.BuildStepInputInfo},System.Object[])">
            <summary>
            Creates an instance of the build helper object.
            </summary>
            <param name="inputsChosen">The inputs set, out of <see cref="P:JetBrains.Build.Running.Storage.IBuildHelper.InputsChoice" />, chosen for the instantiation. This tells which .ctor to use.</param>
            <param name="inputvalues">Values for the .ctor input parameters.</param>
            <returns>The instance.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildStepRunnable">
            <summary>
            Represents a build step which can be run if we known its inputs and need to learn its outputs.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildStepRunnable.Inputs">
            <summary>
            Input parameters.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildStepRunnable.Outputs">
            <summary>
            Output parameters.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.IBuildStepRunnable.RunAsync(System.Object[])">
            <summary>
            Runs the build step implementation.
            </summary>
            <param name="inputs">Inputs. Indices correspond to the <see cref="P:JetBrains.Build.Running.Storage.IBuildStepRunnable.Inputs" /> collection.</param>
            <returns>Outputs. Indices correspond to the <see cref="P:JetBrains.Build.Running.Storage.IBuildStepRunnable.Outputs" /> collection.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IHaveCardinality">
            <summary>
            Tells whether it's singular or plural.
            Exact semantic depends on the object it's applied to.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IHaveCardinality.Cardinality">
            <summary>
            Tells whether it's singular or plural.
            Exact semantic depends on the object it's applied to.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.BindIntoLoadedAssemblies">
            <summary>
            Considers assemblies loaded into the current appdomain for remapping by full type name.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.BindTypeByName">
            <summary>
            Default impl. Just looks up the runtime type.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.BindTypeByName.Default">
            <summary>
            The default instance of the default binder.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName">
            <summary>
            Represents an assembly-qualified type name with a name of a member in the type.
            Optionally supports loose-matching with some allowance for a difference in version numbers (expected with assembly binding redirections in effect).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.EqualityByLooseVersionMatch">
            <summary>
            Requires a match in Major.Minor, but allows a difference in subsequent version components.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.EqualityByTypeFullNameOnly">
            <summary>
            Ignores the assembly name completely when checking for type equality.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.AssemblyName">
            <summary>
            Gets or sets the assembly name of the assembly containing the type identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.MemberName">
            <summary>
            Gets or sets the name of the member identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.TypeFullName">
            <summary>
            Gets or sets the full name of the type identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.TypeLocalName">
            <summary>
            Gets the local name of the type, if the type name is set.
            Calculated.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.TypeNamespace">
            <summary>
            Gets the namespace of the type, if the type name is set.
            Calculated.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.AsBareAssemblyName">
            <summary>
            Returns a copy which has only the bare assembly name, without any version, culture, or public key specifications on it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Serialization.BindTypeByNameEx.HintBindingIfApplicable(JetBrains.Build.Serialization.IBindTypeByName,JetBrains.Build.Serialization.AssemblyQualifiedTypeName,JetBrains.Build.Serialization.AssemblyQualifiedTypeName)">
            <summary>
            Hints possible binding if (a) the binder is a hinted binder, and (b) the two types have the same full name (but possibly not the same assembly).
            </summary>
            <param name="binder"></param>
            <param name="redirectFrom"></param>
            <param name="redirectTo"></param>
        </member>
        <member name="M:JetBrains.Build.Serialization.BindTypeByNameHinted.AddHintFromTypeFullName(JetBrains.Build.Serialization.AssemblyQualifiedTypeName)">
            <summary>
            When you only know the target type, adds a hint for that type's full name (essentially, tells in which an assembly to look for such a name).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.IBindTypeByName">
            <summary>
            Binds a type upon deserialization when only its assembly-qualified name is known.
            Allows to apply redirection rules, such as changing the version in the assembly full name, or even redirecting assemblies when dealing with build artifacts in script/comnpiled transition.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.IBindTypeByName.Equality">
            <summary>
            Gets the equality comparer for comparing type names before they're bound, assuming that two different type names that bind into the same type should be deemed equal.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.IBindTypeByName.Bind(JetBrains.Build.Serialization.AssemblyQualifiedTypeName,JetBrains.Util.OnError)">
            <summary>
            Binds the type to runtime type by its name.
            This should perform two things:
            (1) Load the appropriate assembly, if needed.
            (2) Loosely bind by partial type name match (e.g. if redirecting to another assembly name), if required.
            </summary>
            <param name="name">Type name. Some binders are not looking at the assembly name, for example.</param>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Build.Serialization.ISerializedValuesResolverLoader.Resolver">
            <summary>
            Gets or lazy-loads the resolver object.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.AssemblyQualifiedTypeName">
            <summary>
            Represents an assembly-qualified type name.
            Optionally supports loose-matching with some allowance for a difference in version numbers (expected with assembly binding redirections in effect).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.EqualityByLooseVersionMatch">
            <summary>
            Requires a match in Major.Minor, but allows a difference in subsequent version components.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.EqualityByTypeFullNameOnly">
            <summary>
            Ignores the assembly name completely when checking for type equality.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.AssemblyName">
            <summary>
            Gets or sets the assembly name of the assembly containing the type identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.TypeFullName">
            <summary>
            Gets or sets the full name of the type identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.TypeLocalName">
            <summary>
            Gets the local name of the type, if the type name is set.
            Calculated.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.TypeNamespace">
            <summary>
            Gets the namespace of the type, if the type name is set.
            Calculated.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.AsBareAssemblyName">
            <summary>
            Returns a copy which has only the bare assembly name, without any version, culture, or public key specifications on it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.ToRealPartType(JetBrains.Application.Parts.IPartCatalogueFactory)">
            <summary>
            Binds to a fully-initialized part catalog type.
            This requires binding to a runtime type currently, so the assembly name must resolve in the current appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.ToRealPartType2(JetBrains.Application.Parts.IPartCatalogueFactory)">
            <summary>
            Binds to a fully-initialized part catalog type.
            This requires binding to a runtime type currently, so the assembly name must resolve in the current appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.ToRuntimeType(JetBrains.Build.Serialization.IBindTypeByName,JetBrains.Util.OnError)">
            <summary>
            Binds to the runtime type.
            The assembly name must resolve in the current appdomain.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.DataHelpers.InstanceTypeInfo">
            <summary>
            <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> serialization helper.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver">
            <summary>
            Stores a list of values.
            Can give out values by base types / interfaces.
            Can serialize them into a storage.
            Upon deserialization, does not unpack the actual values until the instance is actually requested, which allows to install the
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.myMapTypeFullNameToExactInstances">
            <summary>
            Looks up types by their type full name (no assembly name involved). This way we can avoid asking the binder to bind our types, because the exact type is already known from the request. Does not work for bases and interfaces, though.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.myMapTypeToAssignableInstances">
            <summary>
            Looks up types by their AQN (matching rules depend on the binder) or by AQNs of their bases and interfaces, hence “assignable”.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.#ctor(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{System.Object},JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,JetBrains.Build.Serialization.IBindTypeByName)">
            <summary>
            </summary>
            <param name="lifetime">The lifetime for this object, AND the lifetime during which we can still access the <paramref name="storage" /> for on-demand deserialization of the actual values. This also applies to all the storages added later with <see cref="M:JetBrains.Build.Serialization.SerializedValuesResolver.LoadFromStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)" /> calls.</param>
            <param name="instances">Object instances to add. Same as calling <see cref="M:JetBrains.Build.Serialization.SerializedValuesResolver.Register(System.Object)" />.</param>
            <param name="storage">The serialized storage. MUST be available for reading throughout the whole <paramref name="lifetime" />. Same as calling <see cref="M:JetBrains.Build.Serialization.SerializedValuesResolver.LoadFromStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)" /> later.</param>
            <param name="typebinder">Knows how to bind the types written in the storage to actual runtime types. In case there might be multiple alternatives it's critical to match the specific type expected for the usage, e.g. in case of build artifacts.</param>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.LoadFromStorage(System.Func{JetBrains.DataFlow.Lifetime,JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Loads serialized instances from a storage.
            As the storage object must be available thru the whole lifetime of this instance, simplifies tracking by giving you the lifetime to load the storage in.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.LoadFromStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Loads serialized instances from a storage.
            The provided storage object must be available thru the whole lifetime of this instance. Use an overload with lifetime if not sure.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.Register(System.Object)">
            <summary>
            Registers a new instance in this resolver.
            Fluent.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.Resolve(System.Type)">
            <summary>
            Resolves the component by its type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.Resolve``1">
            <summary>
            Resolves the component by its type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.ResolveMultiple``1">
            <summary>
            Resolves the components list by its type.
            It is an error if there are no components of such type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.ResolveMultipleOrEmpty``1">
            <summary>
            Resolves the components list by its type.
            It is an error if there are no components of such type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.Resolve_Wrappers``1(``0,JetBrains.Application.Components.IValueResolveContext)">
            <summary>
            Handles wrapping types like <see cref="T:JetBrains.Application.Components.Optional`1" />, <see cref="T:System.Lazy`1" />, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.ResolveMultiple(System.Type,JetBrains.Application.Components.IValueResolveContext)">
            <summary>
            For the <see cref="T:JetBrains.Application.Components.EnumerableValueResolver" />.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver.Instance">
            <summary>
            A single object instance in this container, either coming as a runtime object instance, or being deserialized from the container.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.NameInfosStreamV3">
            <summary>
            V3 format: a single SEXP file with type infos for ALL instances, and per-instance substorages hold right the value without an intermediate level.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.NameInfoStreamV1">
            <summary>
            V1 format: each instance has its own storage with the name info XAML stream and a substorage for the value itself.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.NameInfoStreamV2">
            <summary>
            V2 format: same as V1, but SEXP not XAML, for faster deserialization and to avoid setting up XAML infrastructure on load.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.NameValueStorageV1V2">
            <summary>
            For V1 and V2 format, a substorage with the value.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.SerializedInstanceRecord">
            <summary>
            Serialization-specific accessor, which allows restored instance to keep FLList all around.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver.LiveInstance">
            <summary>
            An instance which got the real live value as an input.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver.RestoredInstance">
            <summary>
            An instance restored from the persistent storage.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.RestoredInstance.myActualFormat">
            <summary>
            V1, V2, V3 fmt based on how we deserialized.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.RestoredInstance.#ctor(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,JetBrains.Build.Serialization.IBindTypeByName)">
            <summary>
            V1, V2 deserialization ctor.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.StringSerializationHelper">
            <summary>
            Implements string serialization via a <see cref="T:System.Windows.Markup.ValueSerializer" /> or a <see cref="T:System.ComponentModel.TypeConverter" /> attached to the class.
            </summary>
        </member>
    </members>
</doc>
