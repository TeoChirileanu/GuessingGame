<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Decompiler.Core</name>
    </assembly>
    <members>
        <member name="P:JetBrains.Decompiler.Ast.IAccessExpression.IsConditionalAccess">
            <summary>
            True for null-conditional access
            ("?." and "?[]")
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Ast.IDecompiledProperty.Initializer">
            <summary>
            C# 6.0 auto-property initializer
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Ast.IDecompiledProperty.BackingField">
            <summary>
            Compiler-generated backing field for auto-property
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.Ast.FunctionSignatureStyle.Full">
            <summary>
            Includes attributes, modifiers, types, and names.
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.Ast.FunctionSignatureStyle.Compact">
            <summary>
            Includes names only.
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.Ast.FunctionSignatureStyle.CompactSingle">
            <summary>
            Includes the only name (no parenthesis).
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Ast.Constant.Type">
            <summary>
            The type of the value.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Ast.Constant.ElementType">
            <summary>
            The element type corresponding to <see cref="P:JetBrains.Decompiler.Ast.Constant.Type"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Ast.Constant.Value">
            <summary>
            When <see cref="P:JetBrains.Decompiler.Ast.Constant.Type"/> is a enum, this holds value of the underlying type.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Ast.IMemberCallExpression.IsVirtual">
            <summary>
            <b>true</b> for a virtual call (<c>callvirt</c>), <b>false</b> for a non-virtual one
            (<c>call</c>).
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Ast.NodeEx.ChooseFirstSequencePointInstruction(JetBrains.Decompiler.Ast.INode)">
            <summary>
            Finds first instruction from tree
            (from method in which root node instruction is located (if defined))
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Ast.NodeEx.GetParentOrCurrentInstructionReference(JetBrains.Decompiler.Ast.INode)">
            <summary>
            Gets parent instruction if parent exists,
            node.InstructionReference otherwise
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Decompiler.Ast.NodeEx.RemoveInstructionFromSubtree(JetBrains.Decompiler.Ast.INode,JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference)">
            <summary>
            Nulling node.InstructionReference which is equal to specified instruction for all subtree nodes
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Ast.ILocalVariable.InstructionsRange">
            <summary>
            Local variable scope within method
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Ast.ILocalVariable.SetMetadataVariableAndInstructionRange(JetBrains.Decompiler.Ast.ILocalVariable)">
            <summary>
            MetadataVariable = other.MetadataVariable, InstructionsRange = other.InstructionsRange, if other.MetadataVariable not null
            (other.Type should be the same as Type)
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:JetBrains.Decompiler.ControlFlow.FilterRegion.ExceptionVariableIndex">
            <summary>
            Local variable index for exception (or -1)
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.ControlFlow.FilterRegion.InstructionReference">
            <summary>
            stloc.x / pop instruction or null
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.InterruptionChecker">
            <see cref="!:JetBrains.Application.Threading.SeldomInterruptCheckerWithCheckTime"/>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.ParameterUtil.FixImplicitParameterName(JetBrains.Decompiler.Ast.IDecompiledMethod)">
            <summary>
            Ensures that the setter/adder/remover parameter has the correct (for C#) name "value"
            (because in VB is allowed to use any other names)
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.IdentifierUtil.IsIdentifierStartCharacter(System.Char)">
            <summary>
            Checks whether character is identifier-start-character in accordance
            with "Identifiers" (9.4.2) of C# standard
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.IdentifierUtil.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Checks whether character is identifier-part-character in accordance
            with "Identifiers" (9.4.2) of C# standard
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.IdentifierUtil.IsValidIdentifier(System.String)">
            <summary>
            Checks whether string is valid identifier in accordance
            with "Identifiers" (9.4.2) of C# standard
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.IdentifierUtil.IsLetterCharacter(System.Char)">
            <summary>
            Checks whether character is letter-character in accordance
            with "Identifiers" (9.4.2) of C# standard
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.IdentifierUtil.IsCombiningCharacter(System.Char)">
            <summary>
            Checks whether character is combining-character in accordance
            with "Identifiers" (9.4.2) of C# standard
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.IdentifierUtil.IsDecimalDigitCharacter(System.Char)">
            <summary>
            Checks whether character is decimal-digit-character in accordance
            with "Identifiers" (9.4.2) of C# standard
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.IdentifierUtil.IsConnectingCharacter(System.Char)">
            <summary>
            Checks whether character is connecting-character in accordance
            with "Identifiers" (9.4.2) of C# standard
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Render.CSharp.IdentifierUtil.IsFormattingCharacter(System.Char)">
            <summary>
            Checks whether character is formatting-character in accordance
            with "Identifiers" (9.4.2) of C# standard
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Render.CSharp.ExpressionPrecedence">
            <summary>
            Used to omit redundant braces during pretty-printing.
            Names borrowed from 7.3.1.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractRefParamCopyingPostfixExpressionTransformationBase`1">
            <summary>
            <code>
            $temp1 = $refParam;
            $local = Deref($refParam);
            $temp2 = ($temp2Type) ($equivalentType) (($evaluationType) $local + 1); // or $temp2 = op_Increment($local)
            Deref($temp1) = ($refParamType) $temp2;
            </code>
            ->
            <code>
            $local = ($refParamType) Deref($refParam)++;
            </code>
            
            Typecasts involving <c>$equivalentType</c>, <c>$refParamType</c>, <c>$evaluationType</c> and <c>$temp2Type</c> are optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractRefParamCopyingPostfixExpressionTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractRefParamCopyingPrefixExpressionTransformationBase`1">
            <summary>
            <code>
            $temp1 = $refParam;
            $local = ($equivalentType) (($evaluationType) Deref($refParam) + 1); // or $local = op_Increment(Deref($refParam))
            $temp2 = ($temp2Type)  $local;
            Deref($temp1) = ($refParamType) $temp2;
            </code>
            ->
            <code>
            $local = ($refParamType) ++Deref($refParam);
            </code>
            
            Typecasts involving <c>$equivalentType</c>, <c>$refParamType</c>, <c>$evaluationType</c> and <c>$temp2Type</c> are optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractRefParamCopyingPrefixExpressionTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractSimplePrefixExpressionTransformation2">
            <summary>
            <code>
            $local = ($lhsType) (($evaluationType) $argument + ($evaluationType) 1);
            $argument = ($lhsType) $local
            </code>
            ->
            <code>
            ++$argument;
            </code>
            if there are only 2 usages of $local
            or
            <code>
            $local = ($lhsType) (++$argument);
            </code>
            where <c>$argument</c> is one of the following:
            <list type="bullet">
            <item><description>a parameter;</description></item>
            <item><description>a local variable;</description></item>
            <item><description>a field;</description></item>
            <item><description>a property.</description></item>
            <item><description>a Deref(parameter);</description></item>
            <item><description>an indexer with simple target and local variables as indices;</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractArrayCompoundAssignmentTransformationBase`1">
            <summary>
            <code>
            ($arrayCopy = $instance)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] =
              ($lhsType) ($arrayCopy[$indexCopy1, ..., $indexCopy[n]] $op $rhs)
            </code>
            ->
            <code>
            $array[$index[1], ..., $index[n]] $op= $rhs
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractArrayCompoundAssignmentTransformation">
            <inheritdoc />
            <remarks>
            This pattern is only used by unsafe code for incrementing or decrementing pointers.
            </remarks>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractArrayPostfixExpressionTransformationBase`1">
            <summary>
            <code>
            ($arrayCopy = $array)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] =
              ($temp = $arrayCopy[$indexCopy1, ..., $indexCopy[n]]) $op 1;
            </code>
            ->
            <code>
            $temp = $array[$index[1], ..., $index[n]] $op;
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractArrayPostfixExpressionTransformation">
            <inheritdoc />
            <remarks>
            This pattern is only used by unsafe code for incrementing or decrementing pointers.
            </remarks>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingCompoundAssignmentExpressionTransformationBase`1">
            <summary>
            <code>
            $targetCopy = $target;
            $temp2 = ($lhsType) ($temp1 = ($tempType) ($equivalentType) (($evaluationType) $targetCopy.$member $op $rhs))
            $targetCopy.$member = ($lhsType) $temp1;
            </code>
            ->
            <code>
            $temp2 = ($lhsType) ($target.$member $op= $rhs)
            </code>
            
            Typecasts involving <c>$equivalentType</c>, <c>$lhsType</c>, <c>$evaluationType</c> and <c>$tempType</c> are optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingCompoundAssignmentExpressionTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingPostfixExpressionTransformationBase`1">
            <summary>
            Case 1:
            <code>
            $targetCopy = $target;
            $temp2 = ($tempType) ($equivalentType) (($evaluationType) ($temp1 = $targetCopy.$member) + 1)
            $targetCopy.$member = ($lhsType) $temp2;
            </code>
            or
            Case 2 ($temp2 was inlined):
            <code>
            $targetCopy = $target;
            $targetCopy.$member = ($tempType) ($equivalentType) (($evaluationType) ($temp1 = $targetCopy.$member) + 1)
            </code>
            ->
            <code>
            $temp1 = ($lhsType) ($target.$member++)
            </code>
            
            Typecasts involving <c>$equivalentType</c>, <c>$lhsType</c>, <c>$evaluationType</c> and <c>$tempType</c> are optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingPostfixExpressionTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractIndexerPostfixExpressionTransformationBase`1">
            <summary>
            <code>
            ($targetCopy = $target)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] = 
              ($lhsType) (($evaluationType) ($temp = $targetCopy[$indexCopy1, ..., $indexCopy[n]]) $op 1)
            </code>
            ->
            <code>
            $temp = $target[$index[1], ..., $index[n]]++
            </code>
            where <c>$op</c> is either <see cref="F:JetBrains.Decompiler.Ast.OperationType.Add"/> or <see cref="F:JetBrains.Decompiler.Ast.OperationType.Subtract"/>.
            Typecasts involving <c>$lhsType</c> and <c>$evaluationType</c> are optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractIndexerPostfixExpressionTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractSimplePostfixExpressionTransformation">
            <summary>
            Case 1:
            <code>
            $lhsTemp = ($tempType) $argument;
            $rhsTemp = ($tempType) 1;
            $argument = ($lhsType) (($evaluationType) $lhsTemp + ($evaluationType) $rhsTemp);
            </code>
            or
            Case 2 ($rhsTemp was inlined):
            <code>
            $lhsTemp = ($tempType) $argument;
            $argument = ($lhsType) (($evaluationType) $lhsTemp + ($evaluationType) 1);
            </code>
            ->
            or
            Case 2':
            <code>
            $lhsTemp = ($tempType) $argument;
            $argument = ($lhsType) $lhsTemp + ($lhsType) 1);
            </code>
            ->
            <code>
            $argument++;
            </code>
            if there are only 2 usages of $lhsTemp
            or
            <code>
            $lhsTemp = ($tempType) ($argument++);
            </code>
            where <c>$argument</c> is one of the following:
            <list type="bullet">
            <item><description>a parameter;</description></item>
            <item><description>a local variable;</description></item>
            <item><description>a field;</description></item>
            <item><description>a property.</description></item>
            <item><description>a Deref(parameter);</description></item>
            <item><description>an indexer with simple target and local variables as indices;</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractSimplePrefixExpressionTransformation">
            <summary>
            <para>
            <c>$expr += 1</c> -> <c>++$expr</c>
            </para>
            <para>
            <c>$expr -= 1</c> -> <c>--$expr</c>
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractIndexerCompoundAssignmentTransformationBase`1">
            <summary>
            <code>
            ($targetCopy = $target)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] =
              ($lhsType) (($evaluationType) $targetCopy[$indexCopy1, ..., $indexCopy[n]] op $rhs)
            </code>
            ->
            <code>
            $target[$index[1], ..., $index[n]] op= $rhs
            </code>
            Typecasts involving <c>$lhsType</c> and <c>$evaluationType</c> are optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractIndexerCompoundAssignmentTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractCopyingCompoundAssignmentStatementTransformationBase`1">
            <summary>
            Case 1:
            <code>
            $targetCopy = $target;
            $temp = ($tempType) (($equivalentType) (($evaluationType$) $targetCopy.$member op $rhs))
            $targetCopy.$member = ($lhsType) $temp;
            </code>
            or
            Case 2 ($temp was inlined):
            <code>
            $targetCopy = $target;
            $targetCopy.$member = ($tempType) (($equivalentType) (($evaluationType$) $targetCopy.$member op $rhs))
            </code>
            ->
            <code>
            $target.$member op= $rhs
            </code>
            Typecasts involving <c>$equivalentType</c>, <c>$evaluationType</c> and <c>$tempType</c> are optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractSimpleCompoundAssignmentTransformationBase`1">
            <summary>
            <c>$lhs = ($lhsType) (($evaluationType) $lhs op $rhs)</c> -> <c>$lhs op= $rhs</c>
            where <c>$lhs</c> is one of the following:
            <list type="bullet">
            <item><description>a parameter;</description></item>
            <item><description>a local variable;</description></item>
            <item><description>a field;</description></item>
            <item><description>a property.</description></item>
            <item><description>a Deref(parameter);</description></item>
            <item><description>an indexer with simple target and local variables as indices;</description></item>
            </list>
            Typecast involving <c>$lhsType</c> and <c>$evaluationType</c> are optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractSimpleCompoundAssignmentTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractArrayPrefixTransformationBase`1">
            <summary>
            <code>
            ($arrayCopy = $array)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] =
              $arrayCopy[$indexCopy1, ..., $indexCopy[n]] $op 1
            </code>
            ->
            <code>
            $op $array[$index[1], ..., $index[n]]
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Assignment.ExtractArrayPrefixTransformation">
            <inheritdoc />
            <remarks>
            This pattern is only used by unsafe code for incrementing or decrementing pointers.
            </remarks>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Bool.EliminateBoxedTrivialConditionalTransformation">
            <summary>
            <list type="bullet">
            <item><description><c>(box bool) ($1 ? 1 : 0)</c> -> <c>(box bool)$1</c></description></item>
            <item><description><c>(box bool) ($1 ? 0 : 1)</c> -> <c>(box bool)!$1</c></description></item>
            </list>
            where <c>$1</c> is typed as <c>bool</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Bool.SimplifyIntLiteralComparisonTransformation">
            <summary>
            <list type="bullet">
            <item><description><c>A == A</c> -> <c>true</c></description></item>
            <item><description><c>A != A</c> -> <c>false</c></description></item>
            <item><description><c>A == B</c> -> <c>false</c></description></item>
            <item><description><c>A != B</c> -> <c>true</c></description></item>
            </list>
            where A and B are int literals and A != B
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Bool.EliminateTrivialBinaryOperationTransformation">
            <summary>
            <list type="bullet">
            <item><description><c>a || false</c> -> <c>a</c></description></item>
            <item><description><c>false || a</c> -> <c>a</c></description></item>
            <item><description><c>a &amp;&amp; true</c> -> <c>a</c></description></item>
            <item><description><c>true &amp;&amp; a</c> -> <c>a</c></description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Bool.EliminateTrivialConditionalTransformation">
            <summary>
            <list type="bullet">
            <item><description><c>$1 ? true : false</c> -> <c>$1</c></description></item>
            <item><description><c>$1 ? false : true</c> -> <c>!$1</c></description></item>
            </list>
            where <c>$1</c> is typed as <c>bool</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Bool.ReduceBoolToIntegerTypeCastTransformation">
            <summary>
            <c>(int) $1 </c> -> <c>$1 ? 1 : 0</c>
            where <c>$1</c> is typed as <c>bool</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Bool.EliminateNegationTransformation">
            <summary>
            <list type="bullet">
            <item><description><c>!(a || b)</c> -> <c>!a &amp;&amp; !b</c></description></item>
            <item><description><c>!(a &amp;&amp; b)</c> -> <c>!a || !b</c></description></item>
            <item><description><c>!(a &lt; b)</c> -> <c>a >= b</c></description></item>
            <item><description><c>!(a &lt;= b)</c> -> <c>a > b</c></description></item>
            <item><description><c>!(a > b)</c> -> <c>a &lt;= b</c></description></item>
            <item><description><c>!(a >= b)</c> -> <c>a &lt; b</c></description></item>
            <item><description><c>!(a == b)</c> -> <c>a != b</c></description></item>
            <item><description><c>!(a != b)</c> -> <c>a == b</c></description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Bool.ReduceIntegerToBoolTypeCastTransformation">
            <summary>
            <list type="bullet">
            <item><description><c>(bool) 1 </c> -> <c>true</c></description></item>
            <item><description><c>(bool) 0 </c> -> <c>false</c></description></item>
            <item><description><c>(bool) $1 </c> -> <c>$1 != 0</c></description></item>
            </list>
            where <c>$1</c> is typed as integer
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Bool.SimplifyBoolLiteralComparisonTransformation">
            <summary>
            <list type="bullet">
            <item><description><c>(int) $1 == 1</c> -> <c>$1</c> (and vice versa)</description></item>
            <item><description><c>(int) $1 == 0</c> -> <c>!$1</c> (and vice versa)</description></item>
            <item><description><c>(int) $1 != 0</c> -> <c>$1</c> (and vice versa)</description></item>
            <item><description><c>(int) $1 != 1</c> -> <c>!$1</c> (and vice versa)</description></item>
            <item><description><c>(uint) $1 == 1U</c> -> <c>$1</c> (and vice versa)</description></item>
            <item><description><c>(uint) $1 == 0U</c> -> <c>!$1</c> (and vice versa)</description></item>
            <item><description><c>(uint) $1 != 0U</c> -> <c>$1</c> (and vice versa)</description></item>
            <item><description><c>(uint) $1 != 1U</c> -> <c>!$1</c> (and vice versa)</description></item>
            <item><description><c>(uint) $1 > 0U</c> -> <c>$1</c> (and vice versa)</description></item>
            </list>
            where $1 is typed as <c>bool</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Conditional.ExtractConditionalAccessTransformation">
            <summary>
            case 1:
            <code>
            if (target == null)
              [return (type) null];
            [else]
              [return] target.XXX.YYY; // or target[index].YYY; .YYY is optional
            </code>
            or
            case 1':
            <code>
            if (target != null)
              [return] target.XXX.YYY; // or target[index].YYY; .YYY is optional
            [else]
              [return (type) null];
            </code>
            ->
            <code>
            [return] target?.XXX.YYY; // or targetVariable?[index].YYY
            </code>
            
            case 2:
            <code>
            if (!target.HasValue) // target expression has Nullable type
              [return (type) null];
            [else]
              [return] target.GetValueOrDefault().XXX.YYY; // or target.GetValueOrDefault()[index].YYY; .YYY is optional
            </code>
            or
            case 2':
            <code>
            if (target.HasValue) // target expression has Nullable type
              [return] target.GetValueOrDefault().XXX.YYY; // or target.GetValueOrDefault()[index].YYY; .YYY is optional
            [else]
              [return (type) null];
            </code>
            
            * (nullable result value):
            <code>new Nullable()</code> instead of <code>(type) null</code>
            <code>new Nullable(target.XXX.YYY)</code> instead of <code>target.XXX.YYY</code>
            <code>new Nullable(target.GetValueOrDefault().XXX.YYY)</code> instead of <code>target.GetValueOrDefault().XXX.YYY</code>
            ->
            <code>
            [return] target?.XXX.YYY; // or target?[index].YYY
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Conditional.SimplifyConditionalWithLiteralComparisonTransformation">
            <summary>
            <list type="bullet">
            <item><description><c>($B ? 1U : $E) > 0U</c> -> <c>$B || ($E > 0U)</c> (and vice versa)</description></item>
            <item><description><c>($B ? $E : 0U) > 0U</c> -> <c>$B &amp;&amp; ($E > 0U)</c> (and vice versa)</description></item>
            <item><description><c>($B ? $E : 1U) > 0U</c> -> <c>!$B || ($E > 0U)</c> (and vice versa)</description></item>
            <item><description><c>($B ? 0U : $E) > 0U</c> -> <c>!$B &amp;&amp; ($E > 0U)</c> (and vice versa)</description></item>
            </list>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Conditional.SimplifyConditionalWithLiteralComparisonTransformation.Replace(JetBrains.Decompiler.Ast.IBinaryOperationExpression,JetBrains.Decompiler.Ast.OperationType,System.Boolean,JetBrains.Decompiler.Ast.IExpression,JetBrains.Decompiler.Ast.IExpression,JetBrains.Decompiler.Ast.ILiteralExpression)">
            <summary>
            binaryOperation -> [!]condition operationType (expression > 0U)
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Conditional.EliminateRedundantElseTransformation">
            <summary>
            <code>
            if (condition)
            {
              ...
              return/throw/break/continue
            }
            else
            {
              statements
            }
            </code>
            ->
            <code>
            if (condition)
            {
              ...
              return/throw/break/continue
            }
            statements
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Conditional.ExtractConditionalAssignmentTransformation">
            <summary>
            case 1:
            <code>
            if (targetVariable != null)
              result = targetVariable;
            else
              result = elseExpression;
            </code>
            ->
            <code> result = targetVariable ?? elseExpression;</code>
            
            case 2:
            <code>
            if (targetVariable.HasValue) // targetVariable is Nullable type
              result = targetVariable.GetValueOrDefault();
            else
              result = elseExpression;
            </code>
            ->
            <code>
            result = targetVariable ?? elseExpression;
            </code>
            
            case 3:
            <code>
            if (target != null)
              resultVariable = target.XXX.YYY; // or target[index].YYY; .YYY is optional
            else
              resultVariable = (type) null;
            </code>
            or
            case 3':
            <code>
            if (target != null)
              resultVariable = new Nullable(target.XXX.YYY); // or new Nullable(target[index].YYY); .YYY is optional
            else
              resultVariable = new Nullable() ;
            </code>
            ->
            <code>
            resultVariable = target?.XXX.YYY; // or targetVariable?[index].YYY
            </code>
            
            case 4:
            <code>
            if (target.HasValue) // target expression has Nullable type
              resultVariable = target.GetValueOrDefault().XXX.YYY; // or target.GetValueOrDefault()[index].YYY; .YYY is optional
            else
              resultVariable = (type) null;
            </code>
            or
            case 4':
            <code>
            if (target.HasValue) // target expression has Nullable type
              resultVariable = new Nullable(target.GetValueOrDefault().XXX.YYY); // or new Nullable(target.GetValueOrDefault()[index].YYY); .YYY is optional
            else
              resultVariable = new Nullable();
            </code>
            ->
            <code>
            resultVariable = target?.XXX.YYY; // or target?[index].YYY
            </code>
            
            case 5:
            <code>
            if (condition)
              result = thenExpression;
            else
              result = elseExpression;
            </code>
            ->
            <code>
            result = condition ? thenExpression : elseExpression;
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Conditional.ConvertReturnToConditionalTransformation">
            <summary>
            case 1
            <code>
            if (condition) 
              return a;
            else
              return b;
            </code>
            ->
            <code> return condition ? a : b;</code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Conditional.PromoteTypeCastIntoConditionalTransformation">
            <summary>
            <c>($1) ($2 ? $3 : $4)</c> -> <c>$2 ? ($1) $3 : ($1) $4</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Conditional.RightConditionalLiteralTransformation">
            <summary>
            <para>
            <c>$1 ? $2 : false</c> -> <c>$1 &amp;&amp; $2</c>
            </para>
            <para>
            <c>$1 ? $2 : true</c> -> <c>!$1 || $2</c>
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Conditional.LeftConditionalLiteralTransformation">
            <summary>
            <para>
            <c>$1 ? true : $2</c> -> <c>$1 || $2</c>
            </para>
            <para>
            <c>$1 ? false : $2</c> -> <c>!$1 &amp;&amp; $2</c>
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.EliminateCopiesOfClosureFrameVariableTransformation">
            <summary>
            <code>
            var frameVariable = new &lt;&gt;c__DisplayClassX();
            ...
            {
             var frameCopyVariable = frameVariable; ()
             ...
             ...frameCopyVariable...(read usage[s])
             ...
             [frameCopyVariable = (&lt;&gt;c__DisplayClassX) null;]
            }+
            // no write usages of frameCopyVariable except 'frameCopyVariable = frameVariable' and 'frameCopyVariable = (&lt;&gt;c__DisplayClassX) null'
            </code>
            ->
            <code>
            var frameVariable = new &lt;&gt;c__DisplayClassX();
            ...
            ...frameVariable...(read usage[s])
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractOptimizedDelegateCreationTransformation">
            <summary>
            <code>
            $targetVariable = $target;
            ...
            $methodPointer = _methodptr($method);
            $result = new $delegateType((object) $targetVariable, $methodPointer);
            </code>
            ->
            <code>
            $targetVariable = $target;
            ...
            $result = new $delegateType($targetVariable.$method);
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractReturnStaticallyCachedAnonymousDelegateTransformation">
            <summary>
            <code>
            Block $branch:
            ...
            if ($cachedDelegate == null) then goto $then else goto $else
            
            Block $then:
            $cachedDelegate = new $delegateType($bodyMethod);
            return [$cachedDelegate];
            
            Block $else:
            return [$cachedDelegate];
            </code>
            ->
            <code>
            Block $branch:
            ...
            Goto $else
            
            Block $else:
            case 1:
            return ($delegateType) delegate $body
            case 2:
            $delegateType local = ($delegateType) delegate $body;
            return;
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractReturnStaticallyCachedAnonymousDelegateWithTempVariableTransformation">
            <summary>
            <code>
            Block $branch:
            ...
            $local = $cachedDelegate
            if ($local == null) then goto $then else goto $else
            
            Block $then:
            $cachedDelegate = ($temp = new $delegateType($bodyMethod));
            return [$temp];
            
            Block $else:
            return [$local];
            </code>
            ->
            <code>
            Block $branch:
            ...
            Goto $else
            
            Block $else:
            case 1:
            return ($delegateType) delegate $body
            case 2:
            $delegateType local = ($delegateType) delegate $body;
            return;
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractCachedAnonymousDelegateWithTempVariableTransformation">
            <summary>
            <code>
            Block $branch:
            ...
            $local = $cachedDelegate
            if ($local == null) then goto $then else goto $else
            
            Block $then:
            case 1) $cachedDelegate = ($temp = new $delegateType($bodyMethod));
            case 2) $temp = ($cachedDelegate = new $delegateType($bodyMethod));
            $local = $temp
            Goto $else
            
            Block $else:
            ...$local...
            ...
            </code>
            ->
            <code>
            Block $branch:
            ...
            Goto $else
            
            Block $else:
            ...($delegateType) delegate $body...
            ...
            </code>
            The final usage is optional.
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Delegates.NodeMatcherExtensions.MatchStaticallyCachedDelegateFieldIsNullExpression(JetBrains.Decompiler.Utils.NodeMatcherEx.NodeMatcher,System.Boolean,JetBrains.Metadata.Reader.API.IMetadataField@)">
            <summary>
            Determines whether expression matches with "$cachedDelegateField == null"
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Delegates.NodeMatcherExtensions.MatchDelegateCreationExpression(JetBrains.Decompiler.Utils.NodeMatcherEx.NodeMatcher,JetBrains.Metadata.Reader.API.IMetadataTypeInfo,JetBrains.Decompiler.Ast.IDelegateCreationExpression@)">
            <summary>
            Determines whether expression matches with "new $delegateType($bodyMethod)"
            </summary>
            <param name="matcher"></param>
            <param name="ownerType">declaring type of delegate method</param>
            <param name="delegateCreation"></param>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Delegates.NodeMatcherExtensions.MatchCachingDelegateCreationStatement(JetBrains.Decompiler.Utils.NodeMatcherEx.NodeMatcher,JetBrains.Metadata.Reader.API.IMetadataField,JetBrains.Metadata.Reader.API.IMetadataTypeInfo,JetBrains.Decompiler.Ast.IDelegateCreationExpression@)">
            <summary>
            Determines whether statement matches with "$cachedDelegateField = new $delegateType($bodyMethod);"
            </summary>
            <param name="matcher"></param>
            <param name="cachedDelegateField"></param>
            <param name="ownerType">declaring type of cachedDelegateField and delegate method</param>
            <param name="delegateCreation"></param>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Delegates.NodeMatcherExtensions.MatchDoubleAssignmentDelegateCreationStatement(JetBrains.Decompiler.Utils.NodeMatcherEx.NodeMatcher,JetBrains.Metadata.Reader.API.IMetadataField,JetBrains.Metadata.Reader.API.IMetadataTypeInfo,JetBrains.Decompiler.Ast.ILocalVariable@,JetBrains.Decompiler.Ast.IDelegateCreationExpression@)">
            <summary>
            Determines whether statement matches with
            case 1 "$cachedDelegate = ($temp = new $delegateType($bodyMethod));"
            or
            case 2 "$temp = ($cachedDelegate = new $delegateType($bodyMethod));"
            </summary>
            <param name="matcher"></param>
            <param name="cachedDelegateField"></param>
            <param name="ownerType">declaring type of cachedDelegateField and delegate method</param>
            <param name="temp"></param>
            <param name="delegateCreation"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractStaticallyCachedAnonymousDelegateTransformation">
            <summary>
            <code>
            Block $branch:
            ...
            if ($cachedDelegate == null) then goto $then else goto $else
            
            Block $then:
            $cachedDelegate = new $delegateType($bodyMethod);
            Goto $else
            
            Block $else:
            ...$cachedDelegate...
            ...
            </code>
            ->
            <code>
            Block $branch:
            ...
            Goto $else
            
            Block $else:
            ...($delegateType) delegate $body...
            ...
            </code>
            The final usage is optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractLocallyCachedAnonymousDelegateTransformation">
            <summary>
            <para>
            Somewhere:
            <code>
            $cachedDelegate = ($delegateType) null;
            </code>
            </para>
            
            <para>
            <code>
            Block $branch:
            ...
            if $cachedDelegate == null then goto $then else goto $else
            
            Block $then:
            $cachedDelegate = new $delegateType(this.$bodyMethod);
            Goto $else
            
            Block $else:
            ...$cachedDelegate$...
            ...
            </code>
            ->
            <code>
            Block $branch:
            ...
            Goto $else
            
            Block $else:
            ...($delegateType) delegate $body...
            ...
            </code>
            The final usage is optional.
            </para>
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.Transformations.Delegates.ExtractClosuresTransformation.myDependencies">
            <remarks>
            Set an order of closure extraction:
            closure of frameVariable should be extracted after myDependencies[frameVariable] closures
            </remarks>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Delegates.ExtractClosuresTransformation.TryFindLocallyCachedDelegate(JetBrains.Decompiler.Ast.IDelegateCreationExpression,JetBrains.Decompiler.Ast.ILocalVariableReferenceExpression,JetBrains.Decompiler.Ast.IIfStatement@,JetBrains.Decompiler.Ast.IExpressionStatement@)">
            <summary>
            local = frameVariable.CachedDelegateField
            if (local == null)
            {
              temp2 = temp1 = delegateCreation(frameVariable, method)
              frameVariable.CachedDelegateField = temp1
              local = temp2
            }
            ...local...(* usage)
            </summary>
            <returns>* usage of local</returns>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Delegates.ExtractClosuresTransformation.TryFindNullCoalescing(JetBrains.Decompiler.Ast.IDelegateCreationExpression,JetBrains.Decompiler.Ast.ILocalVariableReferenceExpression)">
            <summary>
            frameVariable.CacheField ?? (frameVariable.CacheField = delegateCreation)
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractDelegateComparisonTransformation">
            <summary>
            <c>(Delegate) $lhs $op (Delegate) $rhs</c> -> <c>$lhs $op $rhs</c> where <c>op</c> is either <see cref="F:JetBrains.Decompiler.Ast.OperationType.Equal"/>
            or <see cref="F:JetBrains.Decompiler.Ast.OperationType.NotEqual"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractDelegateCreationTransformation">
            <summary>
            <code>
            $targetCopy = $target;
            $methodPointer = _methodptr($method);
            $result = new $delegateType((object) $targetCopy, $methodPointer);
            </code>
            ->
            <code>
            $result = new $delegateType($target.$method);
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractDelegateOperationTransformation">
            <summary>
            <c>($delegateType) Delegate.Combine((Delgate) $lhs, $(Delegate) $rhs)</c> -> <c>$lhs + $rhs</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Delegates.ExtractVirtualDelegateCreationTransformation">
            <summary>
            <code>
            $targetCopy = $target;
            $methodPointer = __vmethodptr($targetCopy, $method);
            $result = new $delegateType((object) $targetCopy, $methodPointer);
            </code>
            ->
            <code>
            $result = new $delegateType($target.$method);
            </code>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Exceptions.ExceptionEx.MatchThrowPattern(JetBrains.Decompiler.Utils.NodeMatcherEx.NodeMatcher,JetBrains.Decompiler.Ast.ILocalVariable,JetBrains.Decompiler.Ast.IExpressionStatement@,JetBrains.Decompiler.Ast.IIfStatement@,JetBrains.Decompiler.Ast.IExpressionStatement@)">
            <summary>
            <code>
            Exception typedException = (Exception) obj; // typedExceptionInitialization, castToExceptionStatement
            if (typedException == null) // ifStatement
              throw obj/*exceptionObject*/;
            ExceptionDispatchInfo.Capture(typedException).Throw(); // callStatement
            </code>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Exceptions.ExceptionEx.IsExceptionDispatchInfoThrow(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            method is System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Exceptions.ExceptionEx.IsExceptionDispatchInfoCapture(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            method is System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Exceptions.PromoteAwaitIntoCatchTransformation">
            <summary>
            case 1 (one catch with await):
            <code>
            int catchIndex = 0;
            try {...}
            catch (...) { ... catchIndex = index; }
            if (catchIndex == 1) &lt;catch body with await&gt;
            </code>
            =>
            <code>
            try {...}
            catch (...) {&lt;catch body with await&gt;}
            </code>
            or
            case 2  (multiple catches with await):
            <code>
            int catchIndex = 0;
            try {...}
            catch (...) { ... catchIndex = index1; }
            catch (...) { ... catchIndex = index2; }
            ...
            switch (catchIndex) { case index1: &lt;catch body with await 1&gt; case index2: &lt;catch body with await 2&gt; ... }
            </code>
            =>
            <code>
            try {...}
            catch (...) {  }
            catch (...) { &lt;catch body with await 2&gt; }
            ...
            </code>
            </summary>
            <remarks>
            <list type="bullet">
            <item><description>if temporary exception variable is used in &lt;catch body with await&gt; it will be replaced with exception variable</description></item>
            <item><description>Ordinal catch blocks can be present</description></item>
            <item><description>Special case 1: catch with filter</description></item>
            <item><description>Special case 2:
            <code> Exception typedException = (Exception) obj; if (typedException == null) throw obj; ExceptionDispatchInfo.Capture(typedException).Throw(); </code>
            =>
            <code> throw; </code></description></item>
            <item><description>Special case 3: try {...} with only one catch with await is the last statement in original method (return value is Task, not Task&lt;T&gt;) - 'if' is inverted in decompiled method</description></item>
            <item><description>Special case 4: try {...} is single statement inside other try with only finally block</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Exceptions.PromoteAwaitIntoCatchTransformation.MatchAssignment(JetBrains.Decompiler.Ast.INode,JetBrains.Decompiler.Ast.IExpressionStatement@,JetBrains.Decompiler.Ast.ILocalVariable@,JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Decompiler.Ast.ILocalVariable)">
            <summary>
            <code>
            leftVariable = (type) rightVariable; // assignment
            </code>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Exceptions.PromoteAwaitIntoCatchTransformation.TryReplaceThrowPatternWithThrow(JetBrains.Decompiler.Ast.ILocalVariableReferenceExpression)">
            <summary>
            <code>
            Exception typedException = (Exception) obj;
            if (typedException == null)
              throw obj/*exceptionObject*/;
            ExceptionDispatchInfo.Capture(typedException).Throw();
            </code>
            =>
            <code>
            throw;
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Exceptions.PromoteAwaitIntoFinallyTransformation">
            <summary>
            <code>
            object exceptionObject = (object) null;
            int temp = 0;
            try {...}
            catch (object ex) { exceptionObject = ex; }
            &lt;finally body with await&gt;
            object tempExceptionObject = exceptionObject;
            if (tempExceptionObject != null)
            {
              Exception typedException = tempExceptionObject as Exception;
              if (typedException == null)
                throw tempExceptionObject;
              ExceptionDispatchInfo.Capture(typedException).Throw();
            }
            exceptionObject = (object) null;
            </code>
            =>
            <code>
            try {...}
            finally { &lt;finally body with await&gt; }
            </code>
            </summary>
            <remarks>
            Can be combined with inner try-catch: if body of try contains single statement - try with several catch blocks and without finally block
            </remarks>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Exceptions.CombineTryCatchFinallyTransformation">
            <summary>
            <code>
            try
            {
              try $1
            }
            finally $2
            </code>
            ->
            <code>
            try
            $1
            finally $2
            </code>
            provided that the inner try statement has no finally or fault block.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Exceptions.EliminateCatchVariableTransformation">
            <summary>
            <c>catch (object $1)</c> -> <c>catch</c> if <c>$1</c> is not used
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Invocation.OptimizeExtensionMethodCallTransformation.GetCandidateWeight(JetBrains.Metadata.Reader.API.IMetadataMethod,JetBrains.Metadata.Reader.API.IMetadataType[],System.Boolean,System.Boolean,System.Func{JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Metadata.Reader.API.IMetadataType})">
            <returns>
            <para>-1, if parameter types of candidate method do not match to argument types;</para>
            <para>n (n &lt; int.MaxValue), if method has "params" last parameter (with index n) and can be invoked with this arguments 
            (last arguments (maybe 0) have element type of "params" parameter)</para>
            <para>int.MaxValue, if method can be invoked with this arguments (in case of "params" method: last argument type is array (not element type of "params" parameter))</para>
            </returns>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Invocation.ReduceParamArrayTransformation">
            <summary>
            Method(..., params T[] args) {...}
            case 1: call M(..., new T[]{expr1, expr2, ...}) => call M(..., expr1, expr2, ...)
            case 2 (if myEliminateEmptyArrayArgument): call M(..., new T[0]) => call M(...)
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.Transformations.Literals.ReduceLiteralsToFractionsTransformation.myIsDouble">
            <summary>
            true - double, false - float
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Literals.ReduceLiteralsToFractionsTransformation.PresentProduct(JetBrains.Decompiler.Ast.ILiteralExpression,System.Double,System.Double,System.Double,JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            value -> (Numerator/Denominator) * constant -> (Numerator * constant) / Denominator
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Literals.ReduceLiteralsToFractionsTransformation.PresentDivision(JetBrains.Decompiler.Ast.ILiteralExpression,System.Double,System.Double,System.Double,JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            value -> (Numerator/Denominator) / constant -> Numerator / (Denominator * constant)
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.LocalVariables.InlineArrayInitializersTransformation">
            <summary>
            case1:
            local = arrayCreation
            ...
            temp1 = expression1
            ...
            tempN = expressionN
            temp = expression "main expression"
            local[temp1, ..., tempN] = temp
            ...
            
            or
            case 2:
            local = arrayCreation
            ...
            temp1 = expression1
            ...
            tempN = expressionN
            local[temp1, ..., tempN] = expression
            ...
            
            ->
            
            local = arrayCreation
            ...
            local[expression1, ..., expressionN] = expression
            ...
            
            where expression1, ..., expressionN, expression do not change state
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.LocalVariables.InlineCollectionInitializersTransformation">
            <summary>
            local = objectCreation
            ...
            temp1 = expression1
            ...
            tempN = expressionN
            local.Add(temp1, ..., tempN)
            ...
            ->
            local = objectCreation
            ...
            local.Add(expression1, ..., expressionN)
            ...
            
            where expression1, ..., expressionN do not change state
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.LocalVariables.InlineMemberInitializersTransformation">
            <summary>
            local = objectCreation
            ...
            temp = expression
            local.Member = temp
            ...
            ->
            local = objectCreation
            ...
            local.Member = expression
            ...
            
            where expression does not change state
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.LocalVariables.InlineThisTransformation">
            <summary>
            ...
            tempLocalVariable = this
            ...tempLocalVariable[.TypeMember]...
            ->
            ...
            ...this[.TypeMember]...
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.LocalVariables.InlineUtil.TryInlineThisReference(JetBrains.Decompiler.Ast.ReferencesFinder,JetBrains.Decompiler.Ast.IThisReferenceExpression)">
            <summary>
            'copy = this;': if copy has only member access other usages => replace with 'this'
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.LocalVariables.InlineUtil.ExpressionCanChangeState(JetBrains.Decompiler.Ast.IExpression)">
            <summary>
            Checks whether expression can change state (local variables, fields etc.)
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.LocalVariables.EliminateUnusedLocalVariablesAssignmentTransformation">
            <summary>
            <para>
            Let <c>$local</c> be a local with the only reference.
            </para>
            <para>
            Remove <c>$local = $constExpr;</c>.
            </para>
            <para>
            <c>$local = $call</c> -> <c>$call</c>
            </para>
            <para>
            <c>$local = $call ? 1 : 0</c> -> <c>$call</c>
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.ObjectModel.ExtractStaticCtorInitializerTransformation">
            <summary>
            <para>
            <code>
            {
              $field-initializers
              $body
            }
            </code>
            ->
            <code>
            {
              $body
            }
            </code>
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.ObjectModel.ExtractInstanceCtorInitializerTransformation">
            <summary>
            <para>
            <code>
            {
              this..ctor($arg);
              $body
            }
            </code>
            ->
            <code>
              : this($args)
            {
              $body
            }
            </code>
            </para>
            <para>
            <code>
            {
              $field-initializers
              base..ctor($args);
              $body
            }
            </code>
            ->
            <code>
              : base($args)
            {
              $body
            }
            </code>
            </para>
            <para>
            Empty <c>base()</c> call is eliminated. Also instance field initializers are extracted.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.ObjectModel.ExtractCheckCastTransformation">
            <summary>
            <para>
            <c>$1 as $2 == null</c> -> <c>!($1 is $2)</c>
            </para>
            <para>
            <c>$1 as $2 != null</c> -> <c>$1 is $2</c>
            </para>
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Transformations.ObjectModel.ExtractObjectAndCollectionInitializersTransformation.MemberWithArguments.Arguments">
            <remarks>Not null for indexer</remarks>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.ObjectModel.UnwrapFinalizerTransformation">
            <summary>
            <code>
            try
            {
              $body
            }
            finally
            {
              base.Finalize();
            }
            </code>
            ->
            <code>
            $body
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.ObjectModel.ExtractRefTypeTransformation">
            <summary>
            <c>Type.GetTypeFromHandle(__reftypetoken ($1))</c> -> <c>__reftype ($1)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.ObjectModel.ExtractTypeOfTransformation">
            <summary>
            <c>Type.GetTypeFromHandle(__typeref ($1))</c> -> <c>typeof ($1)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.ObjectModel.ReduceNullComparisonTransformation">
            <summary>
            <para>
            <c>$1 &lt;= null</c> -> <c>$1 == null</c>
            </para>
            <para>
            <c>$1 > null</c> -> <c>$1 != null</c>
            </para>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Iterators.IteratorDecompiler.ExtractYieldBreak(JetBrains.Decompiler.ControlFlow.ControlFlowBlock,JetBrains.Decompiler.Ast.IStatement)">
            <summary>
            <code>return false;</code> or <code>resultVariable = false;</code> -> <code>yield break;</code>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Iterators.IteratorDecompiler.ExtractYieldReturn(JetBrains.Decompiler.ControlFlow.ControlFlowBlock,JetBrains.Decompiler.Ast.IStatement)">
            <summary>
            <code>
            this.$currentField = $result;
            this.$state = $successorState;
            return true; or resultVariable = true;
            </code>
            ->
            <code>yield return $result;</code>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Iterators.IteratorDecompiler.AnalyzeDispose(JetBrains.Decompiler.Ast.IBlockStatement,JetBrains.Decompiler.Ast.ILocalVariable)">
            <param name="handlerStatement"></param>
            <param name="stateVariable">local variable for this.&lt;&gt;1__state</param>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Iterators.IteratorDecompiler.CollectStateValues(System.Collections.Generic.List{System.Int32},JetBrains.Decompiler.Ast.IExpression,JetBrains.Decompiler.Ast.ILocalVariable)">
            <summary>
            expression: stateVariable != stateValue1 &amp;&amp; ... &amp;&amp; stateVariable != stateValueN
            -> stateValues = stateValues + {stateValue1, ..., stateValueN}
            </summary>
            <remarks>
            (uint)(stateVariable - startStateValue) > k
            can be used instead of sequence
            stateVariable != startStateValue &amp;&amp; stateVariable != (startStateValue + 1) &amp;&amp; ... &amp;&amp; (stateVariable != startStateValue + k)
            </remarks>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.References.ImplicitDerefInserter">
            <summary>
            <para>
            Make implicit each deref of the form <c>^$1</c> where <c>$1</c> is a parameter/variable/member call having <see cref="T:JetBrains.Metadata.Reader.API.IMetadataReferenceType"/>
            or a <c>this</c> reference in a value type.
            </para>
            <para>
            Replace all other references <c>$1</c> to such variables with <c>@^$1</c> where deref is implicit.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.References.EliminateDerefRefTransformation">
            <summary>
            <c>^@ $1</c> -> <c>$1</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Strings.StringConcatTransformation">
            <summary>
            <c>string.Concat($1, ..., $n) </c> -> <c> $1 + ... + $n </c>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantMemberCallTypeCastTransformation.IsExplicitImplementation(JetBrains.Metadata.Reader.API.IMetadataMethod,JetBrains.Metadata.Reader.API.IMetadataType)">
            <summary>
            Check whether the method is explicity implemented in targetType
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.TypeCasts.MoveTypeCastToLiteralInComparisonTransformation">
            <summary>
            <code>
            (($type) $expr) $op $literal
            </code>
            or
            <code>
            $literal $op (($type) $expr)
            </code>
            where
            $op is comparison operation (unchecked),
            typeof($expr) is integral or char,
            $type is integral (with different constraints for relational and equality $op),
            $type == typeof($literal)
            ->
            <code>
            $expr $op $newLiteral
            </code>
            or
            <code>
            $newLiteral $op $expr
            </code>
            where
            $newLiteral = (typeof($expression)) $literal
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.TypeCasts.ReducePointerToReferenceTypeCastTransformation">
            <summary>
            <c>($refType&amp;) $argument</c> -&gt; <c>&amp;*(($refType*) $argument)</c>
            where <c>$argument</c> has pointer type
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantEqualityTypeCastTransformation">
            <summary>
            <c>($1) $2 == ($1) $3</c> -> <c>$2 == $3</c>
            <c>($1) $2 != ($1) $3</c> -> <c>$2 != $3</c>
            </summary>
            when the following conditions are met:
            <list type="bullet">
            <item><description>the types of <c>$2</c> and <c>$3</c> are same and numeric</description></item>
            <item><description>the basic types of <c>$1</c>, <c>$2</c>, and <c>$3</c> are the same</description></item>
            </list>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantLiteralEqualityTypeCastTransformation">
            <summary>
            <c>($1) $2 == $3</c> -> <c>$2 == $3</c>
            <c>($1) $2 != $3</c> -> <c>$2 != $3</c>
            </summary>
            when the following conditions are met:
            <list type="bullet">
            <item><description>the types of <c>$2</c> and <c>$3</c> are same and numeric</description></item>
            <item><description>the basic types of <c>$1</c>, <c>$2</c>, and <c>$3</c> are the same</description></item>
            </list>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.TypeCasts.EliminateRedundantTypeCastTransformation">
            <summary>
            <c>($1) $2</c> -> <c>$2</c>
            where <c>$2</c> is typed as <c>$1</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractAddressOfTransformation">
            <summary>
            <para>
            <c>($type) @$expr</c> -> <c>($type) &amp;$expr</c> if <c>$type</c> is a pointer or a numeric type.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractFixedStatementTransformation">
            <summary>
            <para>
            <code>
            try
            {
              __pinned $type $variable = $initializer;
              $restOfTry
            }
            finally
            {
              __unpin($variable);
              $restOfFinally
            }  
            </code>
            ->
            <code>
            fixed ($type $variable = $initializer)
            {
              try $restOfTry finally $restOfFinally
            }
            </code>
            </para>
            <para>
            <code>
            __pinned $type $variable = $initializer;
            $body
            __unpin($variable);
            $otherUnpins
            </code>
            ->
            <code>
            fixed ($type $variable = $initializer)
            {
              $body
              $otherUnpins
            }
            </code>
            </para>
            <para>
            <code>
            __pinned $type $variable = $initializer;
            $bodyWithoutUnpin
            </code>
            </para>
            ->
            <code>
            fixed ($type $variable = $initializer)
            {
              $bodyWithoutUnpin
            }
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerSubtractionTransformation">
            <summary>
            <para>
            <c>((IntPtr) $lhs - (IntPtr) $rhs) / $size</c> -> <c>(IntPtr) (($elementType*) $lhs - ($elementType*) $rhs))</c>
            </para>
            <para>
            <c>$elementType</c> is selected based on the types of <c>$lhs</c>, <c>$rhs</c> and <c>$size</c>
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerElementAccessTransformation">
            <summary>
            <c>*($pointer + $index)</c> -> <c>$pointer[$index]</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractNullPointerTransformation">
            <summary>
            <c>($pointerType) 0</c> -> <c>($pointerType) null</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerShiftTransformation">
            <summary>
            <para>
            <c>(IntPtr) $lhs $op $delta</c> -> <c>(IntPtr) (($properUnderlyingType*) $lhs $op $rhs)</c>
            </para>
            <para>
            where <c>$lhs</c> is a pointer or reference type with a given <c>$underlyingType</c> and <c>$op</c> is either <c>+</c> or <c>-</c>.
            </para>
            <para>
            Let <c>$size</c> be the static size of <c>$underlyingType</c> (if known).
            The following cases are possible for <c>$delta</c>:
            <list type="bullet">
            <item><description>
            <c>$delta</c> is an <see cref="T:System.IntPtr"/> literal divisible by <c>$size</c>.
            In this case <c>$rhs</c> is <c>(IntPtr) ($delta / $size)</c> (which will be treated by <see cref="T:JetBrains.Decompiler.Transformations.Unsafe.ReduceIntPtrInPointerBinaryOperationTransformation"/> later)
            and <c>$properUnderlyingType</c> is <c>$underlyingType</c>.
            </description></item>
            <item><description>
            <c>$delta</c> is an <see cref="T:System.IntPtr"/> literal not divisible by <c>$size</c>.
            In this case <c>$rhs</c> is <c>$delta</c> and <c>$properUnderlyingType</c> is <c>byte</c>.
            </description></item>
            <item><description>
            <c>$delta</c> is <c>(IntPtr) $recordCount * sizeof($properUnderlyingType)</c>.
            In this case <c>$rhs</c> is <c>$recordCount</c> and <c>$properUnderlyingType</c> is derived from the above.
            </description></item>
            <item><description>
            <c>$delta</c> is <c>(IntPtr) sizeof($properUnderlyingType)</c>.
            In this case <c>$rhs</c> is <c>1</c> and <c>$properUnderlyingType</c> is derived from the above.
            </description></item>
            <item><description>
            <c>$size</c> of <c>$underlyingType</c> is known statically and <c>$delta</c> is <c>(IntPtr) $recordCount * $size</c>.
            In this case <c>$rhs</c> is <c>$recordCount</c> and <c>$properUnderlyingType</c> is <c>$underlyingType</c>.
            </description></item>
            <item><description>
            <c>$size</c> of <c>$underlyingType</c> is 1 and <c>$delta</c> is <c>(IntPtr) $recordCount</c>.
            In this case <c>$rhs</c> is <c>$recordCount</c> and <c>$properUnderlyingType</c> is <c>$underlyingType</c>.
            </description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerOrReferenceComparisonTransformation">
            <summary>
            <para>
            <c>($evaluationType) $lhs $op ($evaluationType)$ rhs</c> -> <c>$lhs $op $rhs</c>
            </para>
            <para>
            where <c>$op</c> is <c>==</c>, <c>!=</c>, <c>&lt;</c>, <c>&lt;=</c>, <c>&gt;</c>, <c>&gt;=</c>,
            <c>$lhs</c> and <c>$rhs</c> are pointers, and <c>$evaluationType</c> is either a pointer, a reference, <see cref="T:System.IntPtr"/> or <see cref="T:System.UIntPtr"/>.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractMultibyteStackAllocTransformation">
            <summary>
            <code>
            $lengthTemp = (IntPtr) (UIntPtr) (uint) $length;
            $elementSizeTemp = $size;
            $totalSizeTemp = checked ($lengthTemp * $elementSizeTemp);
            $arrayTemp = __untypedstackalloc($totalSizeTemp);
            $array = ($arrayType) $arrayTemp;
            </code>
            ->
            <code>
            $array = stackalloc $arrayType[$length]
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerFieldAccessTransformation">
            <summary>
            <c>(*$target).$field</c> -> <c>$target->$field</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerMethodCallTransformation">
            <summary>
            <c>(*$target).$method($args)</c> -> <c>$target->$method($args)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractPointerPropertyAccessTransformation">
            <summary>
            <c>(*$target).$property</c> -> <c>$target->$property</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractReferencePinTransformation">
            <summary>
            <para>
            <code>
            $pinned = $initializer;
            </code>
            ->
            <code>
            __pinned $underlyingType* $newVariable = &amp;*$initializer;
            </code>
            where <c>$initializer</c> has a reference type.
            </para>
            <para>
            </para>
            <code>
            $pinnedVariable =
              ($tempArray = $initializer) == null || $tempArray.Length == 0
              ? ($pinnedType) IntPtr.Zero
              : ($pinnedType) @$tempArray[0];
            </code>
            ->
            <code>
            __pinned $underlyingType* $newPinned = $initializer;
            </code>
            where <c>$initializer</c> has an array type.
            <para>
            <c>$pinned = ($pinnedType) 0;</c> -> <c>__unpin($newPinned);</c>
            </para>
            <para>
            Each reference to <c>$pinned</c> is replaced by <c>($pinnedType) $newPinned</c>.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractStringPinTransformation">
            <summary>
            <para>
            Case 1:
            <code>
            $pinned = $initializer;
            $charPointer = (IntPtr) $pinned;
            if ($charPointer != IntPtr.Zero)
            {
              $offset = System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData;
              $charPointer += (IntPtr) $offset;
            }
            </code>
            or
            Case 2: the same code but with inlined $offset variable 
            ->
             <code>
            __pinned char* $newPinned = $initializer;
            </code>
            </para>
            <para>
            <c>$pinned = (string) null;</c> -> <c>__unpin($newPinned);</c>
            </para>
            <para>
            Each reference to <c>$charPointer</c> is replaced by <c>($charPointerType) $newPinned</c>.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ExtractByteStackAllocTransformation">
            <summary>
            <code>
            $lengthTemp = (IntPtr) (UIntPtr) (uint) $length;
            $arrayTemp = __untypedstackalloc($lengthTemp);
            $array = ($arrayType) $arrayTemp;
            </code>
            ->
            <code>
            $array = stackalloc $arrayType[$length];
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.ReducePointerDiffTypeCastTransformation">
            <summary>
            <para>
            <c>($type[1]) ... ($type[n]) ($pointer1 - $pointer2)</c> -> <c>($type[1]) ($pointer1 - $pointer2)</c>
            </para>
            <para>
            where <c>$type[i]</c> is either <c>IntPtr</c>, <c>UIntPtr</c>, <c>long</c>, or <c>ulong</c>.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Unsafe.IndirectionToZeroElementAccessReducer">
            <summary>
            <para>
            <c>*$pointer</c> -> <c>$pointer[0]</c>
            </para>
            <para>
            where <c>$pointer</c> is either a fixed or stackalloc array.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractRefParamCopyingUserDefinedPostfixExpressionTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractRefParamCopyingUserDefinedPrefixExpressionTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractSimpleUserDefinedPrefixExpressionTransformation2">
            <summary>
            <code>
            $temp = $op($argument);
            $argument = $temp;
            </code>
            ->
            <code>
            ++$argument;
            </code>
            if there are only 2 usages of $temp
            or
            <code>
            $temp = ++$argument;
            </code>
            where <c>$op</c> is either <c>op_Increment</c> or <c>op_Decrement</c> and
            <c>$argument</c> is one of the following:
            <list type="bullet">
            <item><description>a parameter;</description></item>
            <item><description>a local variable;</description></item>
            <item><description>a field;</description></item>
            <item><description>a property.</description></item>
            <item><description>a Deref(parameter);</description></item>
            <item><description>an indexer with simple target and local variables as indices;</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractUserDefinedConditionalLogicTransformation2">
            <summary>
            <para>
            Conditional or:
            <code>
            Block $branch:
              ...
              $local = $lhs;
            If op_True($local) then goto $thenBlock else goto $elseBlock
            
            Block $thenBlock:
              $result = $local;
            Control flow behavior: goto $done
            
            Block $elseBlock:
              $result = $local | $rhs;
            Control flow behavior: goto $done
            </code>
            ->
            <code>
            Block $branch:
              ...
              $result = $lhs || $rhs;
            Control flow behavior: goto $done
            </code>
            </para>
            <para>
            Conditional and:
            <code>
            Block $branch:
              ...
              $local = $lhs;
            If op_False($local) then goto $thenBlock else goto $elseBlock
            
            Block $thenBlock:
              $result = $local;
            Control flow behavior: goto $done
            
            Block $elseBlock:
              $result = $local &amp; $rhs;
            Control flow behavior: goto $done
            </code>
            ->
            <code>
            Block $branch:
              ...
              $result = $lhs &amp;&amp; $rhs;
            Control flow behavior: goto $done
            </code>
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ReduceOpFalseTransformation">
            <summary>
            <para>
            <c>!op_False($1)</c> -> <c>$1</c>
            in a context where a <c>boolean-expression</c> is expected (see 7.20).
            </para>
            <para>
            <c>op_False($1)</c> -> <c>$1 ? false : true</c> in all contexts.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractArrayUserDefinedCompoundAssignmentTransformation">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractArrayUserDefinedPostfixExpressionTransformation">
            <summary>
            <code>
            ($arrayCopy = $array)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] =
              $op($temp = $arrayCopy[$indexCopy1, ..., $indexCopy[n]]);
            </code>
            ->
            <code>
            $temp = $array[$index[1], ..., $index[n]] $op;
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractArrayUserDefinedPrefixTransformation">
            <summary>
            <code>
            ($arrayCopy = $array)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] =
              $op($arrayCopy[$indexCopy1, ..., $indexCopy[n]])
            </code>
            ->
            <code>
            $op $array[$index[1], ..., $index[n]]
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractIndexerUserDefinedCompoundAssignmentTransformation">
            <summary>
            <code>
            ($targetCopy = $target)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] =
              $targetCopy[$indexCopy1, ..., $indexCopy[n]] $op $rhs
            </code>
            ->
            <code>
            $target[$index[1], ..., $index[n]] $op= $rhs
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractIndexerUserDefinedPostfixExpressionTransformation">
            <summary>
            <code>
            ($targetCopy = $target)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] =
              $op($temp = $targetCopy[$indexCopy1, ..., $indexCopy[n]]);
            </code>
            ->
            <code>
            $temp = $target[$index[1], ..., $index[n]] $op;
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractIndexerPrefixTransformation">
            <summary>
            <code>
            ($targetCopy = $target)[$indexCopy1 = $index[1], ..., $indexCopy[n] = $index[n]] = $op($targetCopy[$indexCopy[1], ..., $indexCopy[n]])
            </code>
            ->
            <code>
            $op $taret[$index[1], ..., $index[n]]
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingUserDefinedCompoundAssignmentExpressionTransformation">
            <summary>
            <code>
            $targetCopy = $target;
            $temp2 = ($temp1 = ($targetCopy.$member $op $rhs))
            $targetCopy.$member = $temp1;
            </code>
            ->
            <code>
            $temp2 = ($target.$member $op= $rhs)
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingUserDefinedCompoundAssignmentStatementTransformation">
            <summary>
            <code>
            $targetCopy = $target;
            $temp = ($targetCopy.$member op $rhs))
            $targetCopy.$member = $temp;
            </code>
            ->
            <code>
            $target.$member op= $rhs
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingUserDefinedPostfixExpressionTransformation">
            <summary>
            <code>
            $targetCopy = $target;
            $temp2 = $op($temp1 = $targetCopy.$member))
            $targetCopy.$member = $temp2;
            </code>
            ->
            <code>
            $temp1 = $target.$member $op
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingPrefixExpressionTransformation">
            <summary>
            <code>
            $targetCopy = $target;
            $temp1 = ($temp2 = $op($targetCopy.$member))
            $targetCopy.$member = $temp2;
            </code>
            ->
            <code>
            $temp1 = $op $target.$member
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractCopyingPrefixStatementTransformation">
            <summary>
            <code>
            $targetCopy = $target;
            $temp = $op($targetCopy.$member)
            $targetCopy.$member = $temp;
            </code>
            ->
            <code>
            $op $target.$member
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractSimpleUserDefinedCompoundAssignmentTransformation">
            <summary>
            <c>$lhs = $lhs $op $rhs</c> -> <c>$lhs $op= $rhs</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractSimpleUserDefinedPostfixExpressionTransformation">
            <summary>
            <code>
            $temp = $argument;
            $argument = $op($temp);
            </code>
            ->
            <code>
            $argument++;
            </code>
            if there are only 2 usages of $temp
            or
            <code>
            $temp = ($argument++);
            </code>
            where <c>$op</c> is either <c>op_Increment</c> or <c>op_Decrement</c> and
            <c>$argument</c> is one of the following:
            <list type="bullet">
            <item><description>a parameter;</description></item>
            <item><description>a local variable;</description></item>
            <item><description>a field;</description></item>
            <item><description>a property.</description></item>
            <item><description>a Deref(parameter);</description></item>
            <item><description>an indexer with simple target and local variables as indices;</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractSimpleUserDefinedPrefixExpressionTransformation">
            <summary>
            <c> $argument = $op($argument) </c>  ->  <c> $op $argument </c>
            where <c>$op</c> is either <c>op_Increment</c> or <c>op_Decrement</c> and
            <c>$argument</c> is one of the following:
            <list type="bullet">
            <item><description>a parameter;</description></item>
            <item><description>a local variable;</description></item>
            <item><description>a field;</description></item>
            <item><description>a property.</description></item>
            <item><description>a Deref(parameter);</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ExtractUserDefinedConditionalLogicTransformation">
            <summary>
            <para>
            Conditional or:
            <code>
            Block $branch:
              ...
              $result = $lhs;
            If op_True($result) then goto $done else goto $evaluate
            
            Block $evaluate:
              $rhsTemp = $rhs;
              $result |= $rhsTemp;
            Control flow behavior: goto $done
            </code>
            ->
            <code>
            Block $branch:
              ...
              $result = $lhs || $rhs;
            Control flow behavior: goto $done
            </code>
            </para>
            <para>
            Conditional and:
            <code>
            Block $branch:
              ...
              $result = $lhs;
            If op_False($result) then goto $done else goto $evaluate
            
            Block $evaluate:
              $rhsTemp = $rhs;
              $result &amp;= $rhsTemp;
            Control flow behavior: goto $done
            </code>
            ->
            <code>
            Block $branch:
              ...
              $result = $lhs &amp;&amp; $rhs;
            Control flow behavior: goto $done
            </code>
            </para>
            <para>
            $rhsTemp variable can be inlined
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.UserDefinedOperators.ReduceOpTrueTransformation">
            <summary>
            <para>
            <c>op_True($1)</c> -> <c>$1</c>
            in a context where a <c>boolean-expression</c> is expected (see 7.20).
            </para>
            <para>
            <c>op_True($1)</c> -> <c>$1 ? true : false</c> in all contexts.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Arrays.EliminateArrayAddressDerefTransformation">
            <summary>
            <c>*$array.Address($index[1], ..., $index[n])</c> -> <c>$array[$index[1], ..., $index[n]]</c>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Arrays.ExtractArrayAssignmentInitializerTransformation.TryExtractLiteralInitializerFromInlinedArrayInitialization(JetBrains.Decompiler.Ast.IArrayCreationExpression,System.Int32[])">
            <summary>
            RuntimeHelpers.InitializeArray((Array) new type[dimensions] /*arrayCreation*/, fieldReference)
            ->
            new type[dimensions]{literal initializer}
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Arrays.ExtractArrayAssignmentInitializerTransformation.GetLiteralInitializerData(JetBrains.Decompiler.Metadata.MetadataTypeCache,JetBrains.Decompiler.Ast.ReferencesFinder,JetBrains.Metadata.Reader.API.IImageBodyReader,JetBrains.Decompiler.Ast.ILocalVariable,JetBrains.Decompiler.Ast.IStatement@,JetBrains.Decompiler.Ast.IExpressionStatement@,JetBrains.Decompiler.Ast.IExpressionStatement@)">
            <summary>
            Case 1:
            <code>
            handleVariable = fieldReference // handleAssignmentStatement
            RuntimeHelpers.InitializeArray((Array) arrayVariable, handleVariable) // initStatement
            </code>
            or
            Case 2 (handleVariable was inlined)
            <code>
            // handleAssignmentStatement is absent
            RuntimeHelpers.InitializeArray((Array) arrayVariable, fieldReference) // initStatement
            </code>
            </summary>
            <returns>data from fieldReference (field initial value)</returns>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Arrays.ExtractArrayAssignmentInitializerTransformation.ExtractLiteralInitializer(JetBrains.Decompiler.Ast.IArrayCreationExpression,JetBrains.Decompiler.Ast.ILocalVariable,System.Int32[],JetBrains.Decompiler.Ast.IStatement@)">
            <summary>
            new type[dimensions] // arrayCreation
            ...
            handleVariable = fieldReference // handleAssignmentStatement
            RuntimeHelpers.InitializeArray((Array) arrayVariable, handleVariable) // initStatement
            ->
            new type[dimensions]{literal initializer}
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Arrays.ExtractArrayAssignmentInitializerTransformation.IsInsideInitializersSection(JetBrains.Decompiler.Ast.IExpression)">
            <summary>
            Inside constructor and
            before base..ctor/this..ctor call (for instance constructor)
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Enums.ExtractEnumBinaryOperationTransformation">
            <summary>
            <para>
            <c>($evaluationType) $lhs $op ($evaluationType) $rhs</c> -> <c>($binaryOperationType) (($enumType) $lhs $op ($enumType) $rhs)</c>
            where <c>$op</c> is one of <c>&amp;</c>, <c>|</c>, <c>^</c>, <c>+</c>, <c>-</c>, <c>==</c>, <c>!=</c>, <c>&gt;</c>, <c>&gt;=</c>, <c>&lt;</c>, <c>&lt;=</c>.
            </para>
            <para>
            In certain cases type casts may be different.
            </para>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Enums.ExtractEnumUnaryOperationTransformation">
            <summary>
            <c>~ ($evaluationType) $arg</c> -> <c>($evaluationType) (~$arg)</c>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Loops.ExtractForEachTransformationBase`1.InlineItemVariable(JetBrains.Decompiler.Ast.ILocalVariableReferenceExpression,JetBrains.Decompiler.Ast.IStatement)">
            <returns>replaced temp local variable</returns>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Loops.ExtractEnumerableForEachTransformation">
            <summary>
            <code>
            $1 enumerator = collection.GetEnumerator()
            try
            {
              while (enumerator.MoveNext())
              {
                ...
                enumerator.Current
                ...
              }
            }
            finally
            {
              enumerator.Dispose()
            }
            [enumerator = new CollectionType.EnumeratorType()] - if CollectionType.EnumeratorType is struct (clearing field of compiler generated class)
            </code>
            or
            <code>
            $0 temp = collection
            $1 enumerator = $temp.GetEnumerator()
            temp = ($0) null;
            try
            {
              while (enumerator.MoveNext())
              {
                ...
                enumerator.Current
                ...
              }
            }
            finally
            {
              if (enumerator != null)
                (IDisposable enumerator).Dispose()
            }
            enumerator = ($1) null;
            </code>
            ($1 implements IDisposable)
            or
            <code>
            $1 enumerator = collection.GetEnumerator()
            while (enumerator.MoveNext())
            {
              ...
              enumerator.Current
              ...
            }
            [enumerator = ($1) null;]
            </code>
            ->
            <code>
            foreach($2 item in collection)
            {
              ...
              item
              ...
            }
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Loops.ExtractIndexForEachTransformation">
            <summary>
            <code>
            $1 list = $2;
            for (int index = 0; index &lt; list.Length; ++index)
              $3
            </code>
            ->
            <code>
            foreach ($4 item in list)
              $3
            </code>
            Here $4 is the element type of <c>list</c>, $3 contains the only read usage of <c>index</c>, namely of the form <c>list[index]</c>.
            The latter usage is replaced by <c>item</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Switch.ExtractLargeStringSwitchRoslynTransformation.SwitchExtractor.MatchStringIsEmptyCheck(JetBrains.Decompiler.Ast.IExpression,JetBrains.Decompiler.Ast.IExpression,System.Boolean@)">
            <summary>
            expression is stringExpression.Length == 0 or stringExpression.Length != 0
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Switch.ExtractSwitchTreeTransformation.TreeAnalyzer.IsInside(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64})">
            <summary>
            value in [lowerBound, upperBound]
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Switch.ExtractSwitchTreeTransformation.TreeAnalyzer.IsInside(System.Int64,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64})">
            <summary>
            [rangeStart, rangeStart+rangeLength] in [lowerBound, upperBound]
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.Switch.ExtractSwitchTreeTransformation.MatchOptionalDoubleTypeCast``1(JetBrains.Decompiler.Ast.IExpression,JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Metadata.Reader.API.IMetadataType,``0@)">
            <summary>
            expression is [(expectedTpe1)[(expectedType2)]]innerExpression
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Switch.ExtractBoolSwitchTransformation">
            <summary>
            <code>
            switch ($expr ? 1 : 0)
            {
              case 1: $true-block;
              case 0: $false-block;
            }
            </code>
            ->
            <code>
            switch ($expr)
            {
              case true: $true-block;
              case false: $false-block;
            }
            </code>
            where <c>$expr</c> is typed as bool
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Switch.SimplifySwitchTransformation">
            <summary>
            <para>
            Eliminate empty case if no default clause is present.
            </para>
            <para>
            Put default clause after the switch statement if all switch cases are terminating.
            <code>
            switch ($expr)
            {
              $cases
              default: $default-handler
            }
            </code>
            ->
            <code>
            switch ($expr)
            {
              $cases
            }
            $default-handler
            </code>
            </para>
            <para>
            Eliminate empty default clause.
            <code>
            switch ($expr)
            {
              $cases
              default: ;
            }
            </code>
            ->
            <code>
            switch ($expr)
            {
              $cases
            }
            </code>
            </para>
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Transformations.CompoundAssignmentUtil.MatchLoadExpression(JetBrains.Decompiler.Ast.ILocalVariable,JetBrains.Decompiler.Ast.IExpression,JetBrains.Decompiler.Ast.IExpression,JetBrains.Decompiler.Ast.IExpression@)">
            <summary>
            <para>
            If loadExpression matches
            </para>
            1)
            <code>
            $targetCopyVariable.Field
            </code>
            2)
            <code>
            $targetCopyVariable.Property
            </code>
            3)
            <code>
            *$targetCopyVariable
            </code>
            <para>
            then lhsExpression becomes
            </para>
            1)
            <code>
            $target.Field
            </code>
            2)
            <code>
            $target.Property
            </code>
            3)
            <code>
            $target
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Generics.ExtractConditionalTypeArgumentCreationTransformation">
            <summary>
            <c>__box(default ($1), $1) == null ? System.Activator.CreateInstance&lt;$1&gt;() : default($1)</c> -> <c>new $1()</c>
            where <c>$1</c> is a type argument having <see cref="F:JetBrains.Metadata.Reader.API.GenericArgumentAttributes.DefaultConstructorConstraint"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Generics.ExtractReturnTypeArgumentCreationTransformation">
            <summary>
            <code>
            if (__box(default ($1), $1) != null)
              return default($1);
            else
              return System.Activator.CreateInstance&lt;$1&gt;();
            </code>
            ->
            <code>
            return new $1();
            </code>
            where <c>$1</c> is a type argument having <see cref="F:JetBrains.Metadata.Reader.API.GenericArgumentAttributes.DefaultConstructorConstraint"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Lock.ExtractLock20Transformation">
            <summary>
            case 1:
            <code>
            Monitor.Enter((object) ($copy = $expr));
            try
            {
              $body
            }
            $MonitorExitBlock
            </code>
            or
            case 2:
            <code>
            $copy = $expr;
            Monitor.Enter((object) $copy);
            try
            {
              $body
            }
            $MonitorExitBlock
            </code>
            where $MonitorExitBlock:
            <code>
            finally
            {
              Monitor.Exit((object) $copy);
            }
            [$copy = (ExprType) null]
            </code>
            ->
            <code>
            lock ($expr)
              $body
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Lock.ExtractLock40Transformation">
            <summary>
            case 1:
            <code>
            $flag = false;
            try
            {
              Monitor.Enter((object) ($copy = $expr), ref $flag);
              $body
            }
            $MonitorExitBlock
            </code>
            or
            case 2:
            <code>
            $copy = $expr
            $flag = false;
            try
            {
              Monitor.Enter((object) ($copy), ref $flag);
              $body
            }
            $MonitorExitBlock
            </code>
            or
            case 3:
            <code>
            $flag = false;
            try
            {
              $copy = $expr;
              Monitor.Enter((object) $copy, ref $flag);
              $body
            }
            $MonitorExitBlock
            </code>
            where $MonitorExitBlock:
            <code>
            finally
            {
              if ($flag)
              {
                Monitor.Exit((object) $copy);
              }
            }
            [$copy = (ExprType) null]
            </code>
            ->
            <code>
            lock ($expr)
              $body
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Lock.ExtractLockNull20Transformation">
            <summary>
            <code>
            Monitor.Enter((object) null);
            try
              $body
            finally
            {
              Monitor.Exit((object) null);
            }
            </code>
            ->
            <code>
            lock (null)
              $body
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Lock.ExtractLockNull40Transformation">
            <summary>
            <code>
            var $flag = false;
            try
            {
              Monitor.Enter((object) null, &amp;$flag);
              $body
            }
            finally
            {
              if ($flag)
              {
                Monitor.Exit((object) null);
              }
            }
            </code>
            ->
            <code>
            lock (null)
              $body
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Using.ExtractNotNullableUsingTransformation">
            <summary>
            <code>
            $copy = $disposable;
            try
            {
              $body
            }
            finally
            {
              ((IDisposable) __box($copy, $type)).Dispose();
            }
            </code>
            ->
            <code>
            using (var $copy = $disposable)
              $body
            </code>
            Boxing is optional.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Using.ExtractNullableUsingTransformation">
            <summary>
            <code>
            $copy = $disposable;
            try
            {
              $body
            }
            finally
            {
              if ($copy != null)
                ((IDisposable) $copy).Dispose();
            }
            [$copy = ($type) null;] // where $type is IDisposable or type of $copy variable
            </code>
            or
            <code>
            $temp = $disposable;
            $copy = $temp;
            $temp = (IDisposable) null;
            try
            {
              $body
            }
            finally
            {
              if ($copy != null)
                ((IDisposable) $copy).Dispose();
            }
            [$copy = ($type) null;] // where $type is IDisposable or type of $copy variable
            </code>
            ->
            <code>
            using (var $copy = $disposable)
              $body
            </code>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Arithmetic.ReduceSubtractFromZeroTransformation">
            <summary>
            <c>0 - $1</c> -> <c>-$1</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Arithmetic.ReducePlusMinusTransformation">
            <summary>
            <code>
            $1 + c -> $1 - (-c)
            c + $1 -> $1 - (-c)
            </code>
            for a negative constant c
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.Boxing.ReduceUnboxTransformation">
            <summary>
            <c>__unbox($arg, $type)</c> -> <c>($type) $arg</c>
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.StatementStructure.EliminateEmptyStatementTransformation">
            <summary>
            Remove empty statement.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.StatementStructure.EliminateEmptyBlockStatementTransformation">
            <summary>
            Remove empty block statement.
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Transformations.StatementStructure.SimplifySingleStatementBlockTransformation">
            <summary>
            <c>{ $1 }</c> -> <c>$1</c>
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.DataFlow.UsageType.Read">
            <summary>
            Normal read usage, like in
            <code>
            Console.WriteLine(foo);
            </code>
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.DataFlow.UsageType.Write">
            <summary>
            Write usage, like in
            <code>
            foo = 1;
            </code>
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.DataFlow.UsageType.ReadWrite">
            <summary>
            Read-write usage, like in
            <c>
            foo++;
            </c>
            </summary>s
        </member>
        <member name="M:JetBrains.Decompiler.Dispatcher.CallInstructionHandlers.TryGetEliminatedBlockInstructionBeforeBranchTarget(JetBrains.Decompiler.ControlFlow.ControlFlowBlock,JetBrains.Decompiler.ControlFlow.ControlFlowBlock,JetBrains.Metadata.IL.Instruction,JetBrains.Metadata.IL.Instruction[])">
            <summary>
            Finds jump instruction (br, br.s, leave, leave.s) from eliminated empty jump block
            (intermediate block between branch and target blocks, 
            before elimination: BranchBlock -> EliminatedEmptyJumpBlock -> TargetBlock)
            </summary>
            <param name="targetBlock"></param>
            <param name="branchBlock"></param>
            <param name="branchInstruction">last instruction from branch block</param>
            <param name="methodInstructions"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Decompiler.Dispatcher.CallInstructionHandlers.TryGetEliminatedBlockInstructionBeforeSwitchTarget(JetBrains.Decompiler.ControlFlow.ControlFlowBlock,JetBrains.Decompiler.ControlFlow.ControlFlowBlock,JetBrains.Metadata.IL.Instruction,JetBrains.Metadata.IL.Instruction[])">
            <summary>
            Finds jump instruction (br, br.s, leave, leave.s) from eliminated empty jump block
            (intermediate block between switch and case blocks, 
            before elimination: SwitchBlock -> EliminatedEmptyJumpBlock -> CaseBlock)
            </summary>
            <param name="caseBlock"></param>
            <param name="switchBlock"></param>
            <param name="switchInstruction">last instruction from switch block (with switch opcode)</param>
            <param name="methodInstructions"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Decompiler.Dispatcher.CallInstructionHandlers.TryGetFirstJumpInstruction(System.Int32,JetBrains.Metadata.IL.Instruction[])">
            <summary>
            Gets first meaningful instruction starting from instruction with offset startInstructionOffset
            if it is jump instruction (br, br.s, leave, leave.s), null otherwise
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Dispatcher.CallInstructionHandlers.PreviousInstructionsCount(JetBrains.Metadata.IL.Instruction,JetBrains.Metadata.IL.Instruction[])">
            <summary>
            Gets count of instructions from which control can be transferred to targetInstruction
            Slow!!!
            </summary>
        </member>
        <member name="F:JetBrains.Decompiler.Naming.NameSuggestion.Null">
            <summary>
            An empty (null) suggestion.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Naming.NameSuggestion.Name">
            <summary>
            If <see cref="P:JetBrains.Decompiler.Naming.NameSuggestion.Name"/> is <b>null</b> then there is a conflict and no name of the given <see cref="P:JetBrains.Decompiler.Naming.NameSuggestion.Kind"/>
            should be suggested.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Naming.NameSuggestion.Kind">
            <summary>
            Suggestion kind.
            If it is <see cref="F:JetBrains.Decompiler.Naming.NameSuggestionKind.Null"/> then no actual suggestion is made.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Naming.NameSuggestion.IsPlural">
            <summary>
            Name is in the plural form
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Naming.NameSuggestion.IsValid">
            <summary>
            
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Utils.MemberInheritanceUtil.HasMember(JetBrains.Metadata.Reader.API.IMetadataClassType,JetBrains.Metadata.Reader.API.IMetadataTypeMember)">
            <summary>
            Checks whether type has a member with name and signature as that of referenceMember
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Utils.Rational.#ctor(System.Int64,System.Int64)">
            <summary>
            Requires simplified rational
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Utils.RationalUtil.GetRationalApproximation(System.Double,System.Int32,System.Double)">
             <summary>
             <para>Find rational approximation to given real number</para>
             <para>David Eppstein / UC Irvine / 8 Aug 1993. With corrections from Arno Formella, May 2008.</para>
            
             <para>Based on the theory of continued fractions.
             if x = a1 + 1/(a2 + 1/(a3 + 1/(a4 + ...)))
             then best approximation is found by truncating this series
             (with some adjustments in the last term).
             </para>
            
             <para>Note the fraction can be recovered as the first column of the matrix</para>
             <code>
              ( a1 1 ) ( a2 1 ) ( a3 1 )
              ( 1  0 ) ( 1  0 ) ( 1  0 )
             </code>
             <para>Instead of keeping the sequence of continued fraction terms,
             we just keep the last partial product of these matrices.</para>
             </summary>
        </member>
        <member name="M:JetBrains.Decompiler.Utils.NodeMatcherEx.NodeMatcher.MatchVariableNulling(JetBrains.Decompiler.Ast.ILocalVariable,JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Decompiler.Ast.IExpressionStatement@)">
            <summary>
            variable = [(type)] null;
            </summary>
        </member>
        <member name="T:JetBrains.Decompiler.Src.Utils.DecompilerLicenceResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Src.Utils.DecompilerLicenceResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Src.Utils.DecompilerLicenceResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:JetBrains.Decompiler.Src.Utils.DecompilerLicenceResources.DecompilerLegalNotice">
             <summary>
               Looks up a localized string similar to {\rtf1\ansi\ansicpg1251\deff0\deflang1049{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
            {\*\generator Msftedit 5.41.21.2509;}\viewkind4\uc1\pard\sa200\sl276\slmult1\lang9\f0\fs22 IMPORTANT: BY ACCESSING AND USING JETBRAINS DECOMPILER, YOU AGREE TO THE CERTAIN TERMS AND CONDITIONS SET FORTH IN THE END-USER LICENSE AGREEMENT AND QUOTED BELOW. IF YOU DO NOT AGREE WITH THESE TERMS OR CONDITIONS, DO NOT ACCESS OR USE JETBRAINS DECOMPILER.\par
            The Software includes decompiling functionality (&quot;JetBrains Decompiler&quot;) th [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="M:JetBrains.Decompiler.LocalVariableManager.GetExceptionVariable(JetBrains.Decompiler.ControlFlow.CatchRegion,JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference@)">
            <summary>
            Gets exception variable and instructionReference for it (or for CatchClause) 
            </summary>
        </member>
        <member name="M:JetBrains.Decompiler.LocalVariableManager.TryGetMethodBodyLocalVariable(System.Int32,JetBrains.Metadata.Reader.API.IMetadataType)">
            <param name="localVariableIndex">local variable index in myMethodBody.LocalVariables or -1</param>
            <param name="localVariableType"></param>
        </member>
    </members>
</doc>
